//! The different back ends for the interface generator. Each supported relay provider has an
//! associated backend. The back ends process interface information and generate interface and
//! configuration files.
use crate::gen::common::Result;
use crate::gen::interface::file::FileInterfaces;
use cubist_config::axelar_manifest::ChainName;
use cubist_config::bridge::{Bridge, ContractBridge};
use cubist_config::paths::ContractFQN;
use cubist_config::util::OrBug;
use cubist_config::{BridgeProvider, Config, ContractName, Target};
use cubist_localchains::provider::Provider;
use cubist_util::tera::TeraEmbed;
use lazy_static::lazy_static;
use rust_embed::RustEmbed;
use std::collections::BTreeMap;
use std::path::{Path, PathBuf};
use tera::{Context, Tera};

use super::APPROVE_CALLER_METHOD_NAME;

#[derive(RustEmbed)]
#[folder = "templates"]
struct CubeTemplates;
impl TeraEmbed for CubeTemplates {}

lazy_static! {
    /// The codegen templates
    pub static ref TEMPLATES: Tera = CubeTemplates::tera_from_prefix("");
}

/// Metadata associated with an artifact generated by a back end. The metadata that we store
/// depends on the type of artifact.
#[derive(Debug)]
pub enum ArtifactMetadata {
    /// No additional metadata
    Empty,
    /// The artifact contains shim contracts
    ContractShims {
        /// The names of the shim contracts in this artifact
        contracts: Vec<ContractName>,
    },
}

/// An artifact generated by a back end (e.g., an interface contract or a configuration file)
#[derive(Debug)]
pub struct Artifact {
    /// The chain that this artifact is associated with
    target: Target,
    /// The name of this artifact
    name: PathBuf,
    /// The content of this artifact
    content: String,
    /// The type-dependent metadata associated with the generated artifact
    metadata: ArtifactMetadata,
}

impl Artifact {
    /// Returns the target chain for this artifact
    pub fn target(&self) -> Target {
        self.target
    }

    /// Returns the name of this artifact
    pub fn name(&self) -> &PathBuf {
        &self.name
    }

    /// Returns the content of this artifact
    pub fn content(&self) -> &String {
        &self.content
    }

    /// Returns the metadata of this artifact
    pub fn metadata(&self) -> &ArtifactMetadata {
        &self.metadata
    }
}

/// A back end that processes interface information and returns a list of artifacts
pub trait Backend {
    /// The name of the back end
    fn name(&self) -> &'static str;
    /// Whether `shim` is a shim contract of `c`
    fn is_shim(
        &self,
        c_t: &Target,
        c_fqn: &ContractFQN,
        shim_t: &Target,
        shim_fqn: &ContractFQN,
    ) -> bool;
    /// NPM packages (name + version) that the generated implementation requires.
    fn npm_dependencies(&self) -> Vec<(String, String)>;
    /// Processes a single interface file
    fn process(&self, file: &FileInterfaces) -> Result<Vec<Artifact>>;
}

impl dyn Backend {
    /// Factory method for creating a backend from a [`BridgeProvider`].
    pub fn create(config: &Config) -> Box<Self> {
        match config.bridge_provider {
            BridgeProvider::Cubist => Box::new(CubistBackend),
            BridgeProvider::Axelar => {
                let all_local = config
                    .network_profile()
                    .endpoints()
                    .flat_map(|e| <Box<dyn Provider>>::try_from(e).ok())
                    .all(|p| p.is_local());
                Box::new(AxelarBackend::new(if all_local {
                    AxelarNetwork::Localnet
                } else {
                    AxelarNetwork::Testnet
                }))
            }
        }
    }
}

/// The back end for the Cubist relayer
pub struct CubistBackend;

impl Backend for CubistBackend {
    fn name(&self) -> &'static str {
        "cubist"
    }

    fn npm_dependencies(&self) -> Vec<(String, String)> {
        vec![]
    }

    fn is_shim(
        &self,
        c_t: &Target,
        c_fqn: &ContractFQN,
        shim_t: &Target,
        shim_fqn: &ContractFQN,
    ) -> bool {
        c_t != shim_t && c_fqn.is_same_as(shim_fqn)
    }

    fn process(&self, file: &FileInterfaces) -> Result<Vec<Artifact>> {
        let file_name = file.get_target_file();
        let mut result = vec![];

        // Generate the bridge configuration file
        let contracts: Vec<ContractBridge> = file
            .interfaces
            .iter()
            .map(|contract| {
                let functions = contract
                    .get_functions()
                    .iter()
                    .map(|function| {
                        (
                            function.name().clone(),
                            format!(
                                "__cubist_event_{}_{}",
                                contract.get_contract_name(),
                                function.name()
                            ),
                        )
                    })
                    .collect::<BTreeMap<_, _>>();
                ContractBridge::new(contract.get_contract_name().clone(), functions)
            })
            .collect();
        let bridge = Bridge::new(
            file.get_target_file().clone(),
            file.get_sender_target(),
            file.get_receiver_target(),
            contracts,
        );
        result.push(Artifact {
            target: file.get_sender_target(),
            name: file_name.with_extension("bridge.json"),
            content: serde_json::to_string_pretty(&bridge).or_bug("Serializing bridge file"),
            metadata: ArtifactMetadata::Empty,
        });

        // Generate the interface file
        let mut context = Context::new();
        let contract_names: Vec<String> = file
            .interfaces
            .iter()
            .map(|contract| contract.get_contract_name().clone())
            .collect();
        context.insert("file", file);
        context.insert("APPROVE_CALLER_METHOD_NAME", APPROVE_CALLER_METHOD_NAME);
        result.push(Artifact {
            target: file.get_sender_target(),
            name: file_name.clone(),
            content: TEMPLATES
                .render("cubist_sender.tpl", &context)
                .or_bug("Rendering 'cubist_sender' template"),
            metadata: ArtifactMetadata::ContractShims {
                contracts: contract_names,
            },
        });

        Ok(result)
    }
}

/// The back end for the Axelar relayer
pub struct AxelarBackend {
    /// Network for which to generate interfaces
    pub network: AxelarNetwork,
}

pub(crate) const AXELAR_NPM_PACKAGE: &str = "@axelar-network/axelar-gmp-sdk-solidity";
pub(crate) const AXELAR_NPM_PACKAGE_VERSION: &str = "5.6.4";
pub(crate) const AXELAR_SET_TARGET_ADDR_METHOD_NAME: &str = "setTargetAddress";

fn axelar_receiver_file(file_name: &Path) -> PathBuf {
    file_name.with_extension("receiver.sol")
}

fn axelar_receiver_name(contract_name: &str) -> String {
    format!("{contract_name}Interface")
}

/// Different kinds of Axelar networks
#[derive(Clone)]
pub enum AxelarNetwork {
    /// Local network
    Localnet,
    /// Remote test network
    Testnet,
    /// Remote main network
    Mainnet,
}

impl AxelarBackend {
    /// Constructor
    pub fn new(network: AxelarNetwork) -> Self {
        AxelarBackend { network }
    }

    /// Returns Axelar chain name for a given Cubist target and Axelar network
    pub fn to_chain_name(target: Target, net: AxelarNetwork) -> ChainName {
        match target {
            Target::Ethereum => match net {
                AxelarNetwork::Mainnet => ChainName::Ethereum,
                AxelarNetwork::Testnet => ChainName::ethereum_2,
                AxelarNetwork::Localnet => ChainName::Ethereum,
            },
            Target::Polygon => ChainName::Polygon,
            Target::Avalanche => ChainName::Avalanche,
            Target::AvaSubnet => ChainName::Avalanche,
            Target::Stellar => {
                unimplemented!("Axelar is currently not supported for Stellar targets")
            }
        }
    }
}

impl Backend for AxelarBackend {
    fn name(&self) -> &'static str {
        "axelar"
    }

    fn npm_dependencies(&self) -> Vec<(String, String)> {
        vec![(
            AXELAR_NPM_PACKAGE.to_string(),
            AXELAR_NPM_PACKAGE_VERSION.to_string(),
        )]
    }

    fn is_shim(
        &self,
        c_t: &Target,
        c_fqn: &ContractFQN,
        shim_t: &Target,
        shim_fqn: &ContractFQN,
    ) -> bool {
        (c_t != shim_t && c_fqn.is_same_as(shim_fqn))
            || (c_t == shim_t
                && *shim_fqn
                    == ContractFQN::new(
                        axelar_receiver_file(&c_fqn.file),
                        axelar_receiver_name(&c_fqn.name),
                    ))
    }

    fn process(&self, file: &FileInterfaces) -> Result<Vec<Artifact>> {
        let file_name = file.get_target_file();
        let contract_names: Vec<String> = file
            .interfaces
            .iter()
            .map(|contract| contract.get_contract_name().clone())
            .collect();

        let mut result = vec![];

        let mut context = Context::new();
        context.insert("file", file);
        context.insert(
            "axl_dest_chain",
            &Self::to_chain_name(file.get_receiver_target(), self.network.clone()),
        );
        context.insert(
            "target_receiver_import_path",
            &format!("./{}", file.get_target_file().display()),
        );
        context.insert("AXELAR_PACKAGE", AXELAR_NPM_PACKAGE);
        context.insert(
            "AXELAR_SET_TARGET_ADDR_METHOD_NAME",
            AXELAR_SET_TARGET_ADDR_METHOD_NAME,
        );
        context.insert("APPROVE_CALLER_METHOD_NAME", APPROVE_CALLER_METHOD_NAME);

        // Generate the receiver file
        result.push(Artifact {
            target: file.get_receiver_target(),
            name: axelar_receiver_file(&file_name),
            content: TEMPLATES
                .render("axelar_receiver.tpl", &context)
                .or_bug("Rendering 'axelar_receiver' template"),
            metadata: ArtifactMetadata::ContractShims {
                contracts: contract_names
                    .iter()
                    .map(|c| axelar_receiver_name(c))
                    .collect(),
            },
        });
        // Generate the sender file
        result.push(Artifact {
            target: file.get_sender_target(),
            name: file_name.clone(),
            content: TEMPLATES
                .render("axelar_sender.tpl", &context)
                .or_bug("Rendering 'axelar_sender' template"),
            metadata: ArtifactMetadata::ContractShims {
                contracts: contract_names,
            },
        });
        Ok(result)
    }
}
