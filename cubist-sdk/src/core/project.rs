use cubist_config::axelar_manifest::AxelarManifest;
use cubist_config::bridge::Bridge;
use cubist_config::paths::{ContractFQN, Paths, TargetPaths};
use cubist_config::secret::SecretUrl;
use cubist_config::util::OrBug;
use cubist_config::BridgeProvider;
use cubist_config::{
    network::EndpointConfig, Compiler, CompilerConfig, Config, NetworkName, PreCompileManifest,
    Target, TargetConfig,
};
use cubist_localchains::provider::Provider as CubistProvider;
use ethers::abi::Abi;
use ethers::abi::{Token, Tokenize};
use ethers::prelude::transformer::TransformerMiddleware;
use ethers::prelude::*;
use ethers::providers::Provider;
use ethers::types::transaction::eip2718::TypedTransaction;
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::fs;
use std::iter::repeat;
use std::path::{Path, PathBuf};
use std::time::Duration;
use std::{convert::TryFrom, sync::Arc};
use tracing::debug;

use crate::core::{ContractAddress, ContractData, LegacyTransformer};
use crate::hex::serde_hex;
use crate::target_handler::solang::SolangCompiler;
use crate::target_handler::solc::SolcCompiler;
use crate::target_handler::soroban::SorobanCompiler;
use crate::{ContractInfo, CubistSdkError, Result, WrapperError};

type EthersContract<M> = ethers::contract::Contract<M>;

/// Deployment info for a single contract (either shim or not).
#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct DeploymentInfo {
    /// Chain to which the contract was deployed
    pub target: Target,

    /// Contract address
    #[serde(with = "serde_hex")]
    pub address: ContractAddress,
}

/// Per-contract manifest generated by the deployer.
#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct DeploymentManifest {
    /// Deployed contract
    pub contract: ContractFQN,
    /// Non-shim contract's deployment info
    #[serde(flatten)]
    pub deployment: DeploymentInfo,
    /// All of its shims' deployment infos
    pub shims: Vec<DeploymentInfo>,
}

impl DeploymentManifest {
    /// Writes the manifest to a file atomically, which guarantees
    /// that the "deployment watcher" reads it after it has been
    /// flushed.
    pub fn write_atomic(&self, path: &Path) -> Result<(), WrapperError> {
        let content = serde_json::to_string_pretty(self).map_err(|e| {
            WrapperError::JsonError(path.to_path_buf(), "DeploymentManifest".to_owned(), e)
        })?;
        let tmp_file = path.with_extension("tmp");
        let parent_dir = tmp_file.parent().unwrap();
        fs::create_dir_all(parent_dir)
            .map_err(|e| WrapperError::IOError(parent_dir.to_path_buf(), e))?;
        fs::write(&tmp_file, content)
            .map_err(|e| WrapperError::IOError(tmp_file.to_path_buf(), e))?;
        fs::rename(&tmp_file, path)
            .map_err(|e| WrapperError::IOError(tmp_file.to_path_buf(), e))?;
        Ok(())
    }
}

/// The result of a contract compilation.
pub struct CompileResult {
    /// Diagnostics spit out by the compiler.
    pub diagnostics: String,
}

/// An abstraction for a contract compiler.
pub trait ContractCompiler {
    /// Clean build artifacts.
    fn clean(&self) -> Result<()>;

    /// Compile a given contract file.
    fn compile_file(&self, file: &Path) -> Result<CompileResult>;

    /// Find all compiled contracts (on disk) originating from a given source file.
    fn find_compiled_contracts(
        &self,
        source_file: &Path,
    ) -> Result<HashMap<NetworkName, ContractInfo>>;
}

type HttpProvider = Provider<Http>;
type WsProvider = Provider<Ws>;

type Stack<M> = TransformerMiddleware<M, LegacyTransformer>;

/// Type alias for a middleware implementation over HTTP that transforms requests into legacy
/// requests and signs them. The signer sends requests directly through the HTTP provider, because
/// it only issues requests that are answered by the proxy itself, which supports EIP-1599
/// transactions.
pub type HttpStack = Stack<HttpProvider>;

/// Same as `MiddlewareStack` but over web sockets
pub type WsStack = Stack<WsProvider>;

/// Additional bridge information depending on which [`BridgeProvider`] is in use
pub enum BridgeInfo {
    /// Corresponds to [BridgeProvider::Cubist]
    Cubist,
    /// Corresponds to [BridgeProvider::Axelar]
    Axelar(AxelarManifest),
}

/// Metadata about a project target a single chain.
pub struct TargetProjectInfo {
    /// Target chain (e.g., "avalanche", "polygon", etc.)
    pub target: Target,
    /// Compiler to use to compile `source_contracts` (e.g., "solc", "solang", etc.)
    pub compiler: Compiler,
    /// The compiler configuration to use for compiling contracts
    compiler_config: CompilerConfig,
    /// Well-known paths for the whole app
    pub paths: Paths,
    /// Per-target well-known paths
    pub target_paths: TargetPaths,
    /// Optional network configuration (for deployment).
    pub network_config: Option<EndpointConfig>,
    /// What kind of bridge provider is used.
    pub bridge_provider: BridgeProvider,
    /// Manifest containing paths to source contracts and generated shims.
    manifest: PreCompileManifest,
}

/// Generic project targeting a single chain either via HTTP or WS.
pub struct TargetProject<M: Middleware = HttpStack> {
    /// Project for this chain
    project: TargetProjectInfo,
    /// Provider for this chain.
    provider: Arc<M>,
    /// Additional info pertaining to the bridge provider in use.
    pub bridge: BridgeInfo,
}

/// Instances of [`TargetProject`] can be automatically dereferenced
/// to [`TargetProjectInfo`].
impl<M: Middleware> std::ops::Deref for TargetProject<M> {
    type Target = TargetProjectInfo;

    fn deref(&self) -> &Self::Target {
        &self.project
    }
}

async fn wrap<M: JsonRpcClient>(
    provider: Provider<M>,
    target: Target,
) -> Result<Stack<Provider<M>>, WrapperError> {
    if target == Target::Stellar {
        // TODO: This is a dummy transformer
        return Ok(TransformerMiddleware::new(
            provider,
            LegacyTransformer {
                gas_price: 10.into(),
            },
        ));
    }

    let provider = provider.interval(Duration::from_millis(50));

    // Use the first account for all requests if it exists
    // TODO(#261): Allow configuration to override it
    let address = provider
        .get_accounts()
        .await
        .map_err(|e| WrapperError::ProviderError("get_accounts".to_owned(), e.to_string()))?
        .first()
        .copied();

    let provider = match address {
        Some(address) => provider.with_sender(address),
        None => provider,
    };

    // TODO(#261): Allow configuration to override gas price
    let gas_price = provider
        .get_gas_price()
        .await
        .map_err(|e| WrapperError::ProviderError("get_gas_price".to_owned(), e.to_string()))?;
    let fees = provider
        .estimate_eip1559_fees(None)
        .await
        .map_err(|e| WrapperError::ProviderError("estimate_fees".to_owned(), e.to_string()))?;
    debug!(
        "Fees on {target}: gas_price: {gas_price}, max fee per gas: {:?}",
        fees.0
    );
    let gas_price = std::cmp::max(gas_price, fees.0);
    Ok(TransformerMiddleware::new(
        provider,
        LegacyTransformer { gas_price },
    ))
}

/// Factory method for creating an ethers provider over HTTP
async fn create_provider_http(url: &SecretUrl, target: Target) -> Result<HttpStack, WrapperError> {
    let http_scheme = to_http_scheme(url.scheme());
    let exposed_url = url
        .expose_url_and_update(Some(http_scheme), None, None)
        .map_err(WrapperError::ConfigError)?;

    let provider = HttpProvider::try_from(exposed_url.as_str()).map_err(WrapperError::UrlError)?;

    wrap(provider, target).await
}

/// Factory method for creating an ethers provider over WS
async fn create_provider_ws(url: &SecretUrl, target: Target) -> Result<WsStack, WrapperError> {
    let ws_scheme = to_ws_scheme(url.scheme());
    let exposed_url = url
        .expose_url_and_update(Some(ws_scheme), None, None)
        .map_err(WrapperError::ConfigError)?;
    let provider = WsProvider::connect(exposed_url.as_str())
        .await
        .map_err(|e| WrapperError::ProviderError("connect".to_owned(), e.to_string()))?;
    wrap(provider, target).await
}

impl TargetProjectInfo {
    /// Creates a [`TargetProjectInfo`] for that target.
    pub fn new(cubist_config: &Config, target: Target) -> Result<Self> {
        let paths = cubist_config.paths();
        let my_paths = paths
            .try_for_target(target)
            .ok_or(CubistSdkError::MissingTarget(target))?
            .to_owned();
        let manifest = PreCompileManifest::from_file(&my_paths.manifest)
            .map_err(|e| CubistSdkError::MissingManifest(target, e))?;
        let contracts = cubist_config.contracts();
        let target_config = contracts
            .targets
            .get(&target)
            .ok_or(CubistSdkError::MissingTarget(target))?;
        let network_config = cubist_config.network_for_target(target);
        let compiler = match target_config {
            TargetConfig::EvmTargetConfig { compiler, .. } => compiler,
            TargetConfig::StellarTargetConfig { .. } => &Compiler::Soroban,
        };
        Ok(TargetProjectInfo {
            paths,
            target_paths: my_paths,
            compiler: *compiler,
            compiler_config: cubist_config.get_compiler_config(),
            target,
            network_config,
            manifest,
            bridge_provider: cubist_config.bridge_provider.clone(),
        })
    }
}

impl TargetProjectInfo {
    /// Connect to the endpoint using HTTP
    pub async fn connect(self) -> Result<TargetProject<HttpStack>> {
        TargetProject::<HttpStack>::create(self).await
    }

    /// Connect to the endpoint using Web Sockets
    pub async fn connect_ws(self) -> Result<TargetProject<WsStack>> {
        TargetProject::<WsStack>::create(self).await
    }

    /// Return absolute paths to all contract files.
    pub fn contract_files(&self) -> impl Iterator<Item = PathBuf> + '_ {
        self.manifest
            .files
            .iter()
            .map(|f| &f.rel_path)
            .map(|rel| self.target_paths.contracts.join(rel))
            .collect::<HashSet<PathBuf>>()
            .into_iter()
    }

    /// Clean build artifacts
    pub fn clean(&self) -> Result<()> {
        self.compiler().clean()
    }

    /// Compile a contract file.
    pub fn compile_file(&self, file: &Path) -> Result<CompileResult> {
        self.compiler().compile_file(file)
    }

    /// Whether contract `cc` is allowed to call contract `dep` (i.e.,
    /// whether `dep` is a dependency of `cc`)
    pub fn is_dependency(&self, cc: &ContractInfo, dep: &ContractInfo) -> bool {
        self.manifest.is_dependency(&cc.fqn, &dep.fqn)
    }

    /// Find all shim contracts generated for this chain.
    pub fn find_shim_contracts(&self) -> Result<Vec<ContractInfo>> {
        let mut result = Vec::new();
        for source_file in self.manifest.shim_files() {
            for contract in self.find_compiled_contracts(source_file)?.into_values() {
                result.push(contract);
            }
        }
        Ok(result)
    }

    /// Find all (non-shim) contracts targeting this chain.
    pub fn find_contracts(&self) -> Result<Vec<ContractInfo>> {
        let mut result = Vec::new();
        for source_file in self.manifest.contract_files() {
            for contract in self.find_compiled_contracts(source_file)?.into_values() {
                result.push(contract);
            }
        }
        Ok(result)
    }

    /// Find a non-shim contract targeting this chain by its name.
    pub fn contract(&self, name: &str) -> Result<Option<ContractInfo>> {
        let c = self
            .find_contracts()?
            .into_iter()
            .find(|c| c.fqn.name == name);
        Ok(c)
    }

    /// Find a shim contract targeting for chain by its name.
    pub fn shim_contract(&self, name: &str) -> Result<Option<ContractInfo>> {
        let c = self
            .find_shim_contracts()?
            .into_iter()
            .find(|c| c.fqn.name == name);
        Ok(c)
    }

    /// Creates a new instance of a compiler.
    fn compiler(&self) -> Box<dyn ContractCompiler> {
        match self.compiler {
            Compiler::Solc => {
                Box::new(SolcCompiler::new(&self.compiler_config, &self.target_paths))
            }
            Compiler::Solang => Box::new(SolangCompiler),
            Compiler::Soroban => Box::new(SorobanCompiler::new(self.target_paths.clone())),
        }
    }

    /// Find all compiled contracts (on disk) originating from a given source file.
    fn find_compiled_contracts(&self, source_file: &Path) -> Result<HashMap<String, ContractInfo>> {
        self.compiler().find_compiled_contracts(source_file)
    }

    /// Create a cubist localchains provider ([`CubistProvider`]) from a
    /// given [`EndpointConfig`] then return that provider's endpoint url.
    pub fn endpoint_url(&self) -> Result<SecretUrl> {
        let provider: Box<dyn CubistProvider> = self
            .network_config
            .as_ref()
            .ok_or(CubistSdkError::MissingNetworkConfig(self.target))?
            .clone()
            .try_into()?;
        Ok(provider.url())
    }
}

macro_rules! project_constructor {
    ($project: expr, $provider_fn: expr) => {{
        let url = $project.endpoint_url()?;
        let provider = $provider_fn(&url, $project.target).await.map_err(|e| {
            CubistSdkError::CreateClientError($project.target.clone(), url, Some(Box::new(e)))
        })?;
        Ok(Self::new($project, provider)?)
    }};
}

impl TargetProject<HttpStack> {
    /// Factory method for connections over HTTP
    pub async fn create(project: TargetProjectInfo) -> Result<Self> {
        project_constructor!(project, create_provider_http)
    }
}

impl TargetProject<WsStack> {
    /// Factory method for connections over Web Sockets
    pub async fn create(project: TargetProjectInfo) -> Result<Self> {
        project_constructor!(project, create_provider_ws)
    }
}

impl<M: Middleware> TargetProject<M> {
    /// Constructor
    pub fn new(project: TargetProjectInfo, provider: M) -> Result<Self> {
        let bridge = match project.bridge_provider {
            BridgeProvider::Cubist => BridgeInfo::Cubist,
            BridgeProvider::Axelar => {
                let path = &project.target_paths.axelar_manifest;
                let contents = std::fs::read_to_string(path)
                    .map_err(|e| WrapperError::IOError(path.to_path_buf(), e))
                    .map_err(CubistSdkError::LoadAxelarManifest)?;
                let manifest = serde_json::from_str(&contents)
                    .map_err(|e| {
                        WrapperError::JsonError(path.to_path_buf(), "AxelarManifest".to_string(), e)
                    })
                    .map_err(CubistSdkError::LoadAxelarManifest)?;
                BridgeInfo::Axelar(manifest)
            }
        };
        Ok(Self {
            project,
            bridge,
            provider: Arc::new(provider),
        })
    }

    /// Create new or return existing deployer for this project.
    pub fn provider(&self) -> Arc<M> {
        Arc::clone(&self.provider)
    }

    /// Retrieve all accounts used on this target.
    pub async fn accounts(&self) -> Result<Vec<Address>> {
        let acc = self
            .provider
            .get_accounts()
            .await
            .map_err(|e| CubistSdkError::AccountsError(self.target, format!("{e}")))?;
        Ok(acc)
    }

    /// Retrieve all (Soroban) identities used on this target.
    pub fn identities(&self) -> Result<Vec<String>> {
        let config = self.network_config.clone().unwrap();
        let identities = match config {
            EndpointConfig::Stellar(config) => config.identities.clone(),
            _ => unimplemented!(),
        };
        Ok(identities)
    }

    /// Return default sender
    pub async fn sender(&self) -> Result<Address> {
        self.provider.default_sender().ok_or_else(|| {
            CubistSdkError::AccountsError(self.target, "No default sender".to_owned())
        })
    }

    /// Deploy an EVM contract
    pub async fn deploy_evm<T: Tokenize>(
        &self,
        fqn: &ContractFQN,
        abi: &Abi,
        bytes: &Bytes,
        constructor_args: T,
    ) -> Result<ethers::contract::Contract<M>> {
        // TODO: the user should be able to specify 'gas' setting; otherwise, leave it empty
        //       instead of calling 'estimate_gas', because the estimation can be wrong
        let factory = ContractFactory::new(abi.to_owned(), bytes.to_owned(), self.provider());

        let deploy_err = |e| CubistSdkError::DeployError(fqn.clone(), self.target, Box::new(e));

        let args = constructor_args.into_tokens();
        debug!("Deploying {}({:?}) to {}", fqn.name, &args, self.target,);
        let deployer = factory
            .deploy(Token::Tuple(args))
            .map_err(|e| WrapperError::ContractError(e.to_string()))
            .map_err(deploy_err)?;
        let receipt = self.send_tx(deployer.tx).await.map_err(deploy_err)?;
        let address = receipt.contract_address.ok_or_else(|| {
            deploy_err(WrapperError::ContractError(
                "No contract address".to_owned(),
            ))
        })?;
        let deployed = ethers::contract::Contract::new(address, abi.clone(), self.provider());

        debug!(
            "Deployed {} to {} at {:?}",
            fqn.name,
            self.target,
            deployed.address()
        );

        self.save_receipt(fqn, deployed.address(), &receipt).await?;

        Ok(deployed)
    }

    /// Deploy a contract. This method currently only supports the deployment of Solidity contracts
    /// and is effectively for backwards compatibility.
    pub async fn deploy<T: Tokenize>(
        &self,
        contract: &ContractInfo,
        constructor_args: T,
    ) -> Result<ethers::contract::Contract<M>> {
        match &contract.data {
            ContractData::SolidityData { abi, bytes } => {
                self.deploy_evm(&contract.fqn, abi, bytes, constructor_args)
                    .await
            }
            ContractData::SorobanData { .. } => todo!(),
        }
    }

    /// Initialize a given contract with a given address
    pub fn at(&self, contract: &ContractInfo, address: Address) -> EthersContract<M> {
        debug!(
            "Initialized {}@{} to {address}",
            contract.fqn.name, self.target,
        );
        match &contract.data {
            ContractData::SolidityData { abi, .. } => {
                EthersContract::new(address, abi.clone(), self.provider())
            }
            ContractData::SorobanData { .. } => todo!(),
        }
    }

    /// Initialize a given contract from its deployment receipt.
    /// Succeeds only if there is exactly one corresponding deployment receipt found.
    pub async fn deployed(&self, contract: &ContractInfo) -> Result<EthersContract<M>> {
        let receipts = self.find_receipts(&contract.fqn).await?;
        if receipts.is_empty() {
            Err(CubistSdkError::LoadContractNoReceipts(
                contract.fqn.clone(),
                self.target,
            ))
        } else if receipts.len() > 1 {
            Err(CubistSdkError::LoadContractTooManyReceipts(
                contract.fqn.clone(),
                self.target,
            ))
        } else {
            let rec = receipts.first().unwrap();
            Ok(self.at(
                contract,
                rec.contract_address
                    .expect("Transaction receipt should contain contract address"),
            ))
        }
    }

    /// Try to find and load bridge metadata for this contract.
    /// The bridge metadata file is expected to be co-located with the contract's source file.
    pub fn load_bridge(&self, cc: &ContractInfo) -> Result<Bridge> {
        let bridge_file = self.target_paths.for_bridge(&cc.fqn.file);
        let load_bridge_error =
            |e| CubistSdkError::LoadBridgeError(cc.fqn.clone(), bridge_file.clone(), Box::new(e));
        let json = fs::read_to_string(&bridge_file)
            .map_err(|e| WrapperError::IOError(bridge_file.clone(), e))
            .map_err(load_bridge_error)?;
        let bridge = serde_json::from_str::<Bridge>(&json)
            .map_err(|e| WrapperError::JsonError(bridge_file.clone(), "Bridge".to_owned(), e))
            .map_err(load_bridge_error)?;
        Ok(bridge)
    }

    /// Submits a given transaction and waits for a receipts
    pub async fn send_tx(&self, tx: TypedTransaction) -> Result<TransactionReceipt, WrapperError> {
        let send_err = |e| WrapperError::SendTransactionError(format!("{tx:?}"), self.target, e);

        let provider = self.provider();
        let pending_tx = provider
            .send_transaction(tx.clone(), None)
            .await
            .map_err(|e| send_err(e.to_string()))?;

        let tx_hash = pending_tx.tx_hash();
        let receipt = pending_tx.await.map_err(|e| send_err(e.to_string()))?;

        // poll manually if receipt is empty
        let receipt = if receipt.is_none() {
            let delays = repeat(Duration::from_secs(1)).take(60);
            self.poll_tx(tx_hash, delays).await?
        } else {
            receipt
        };

        let receipt = receipt.ok_or_else(|| send_err("No receipt".to_owned()))?;
        Ok(receipt)
    }

    /// Repeatedly tries to fetch the transaction receipt for a given transaction hash.
    ///
    /// # Arguments
    /// * `tx_hash` - the hash of the transaction for which to fetch receipt
    /// * `delays` - how long to wait between retries
    pub async fn poll_tx(
        &self,
        tx_hash: H256,
        delays: impl IntoIterator<Item = Duration>,
    ) -> Result<Option<TransactionReceipt>, WrapperError> {
        let provider = self.provider();
        for d in delays {
            debug!("Fetching receipt for tx {tx_hash:?}");
            let receipt = provider
                .get_transaction_receipt(tx_hash)
                .await
                .map_err(|e| {
                    WrapperError::TransactionNotFound(tx_hash, self.target, e.to_string())
                })?;
            if receipt.is_some() {
                return Ok(receipt);
            }
            tokio::time::sleep(d).await;
        }
        Ok(None)
    }

    async fn save_receipt(
        &self,
        contract: &ContractFQN,
        address: Address,
        receipt: &TransactionReceipt,
    ) -> Result<()> {
        let path = self
            .target_paths
            .for_deployment_receipt(contract, address.as_fixed_bytes());
        let parent_dir = path.parent().or_bug("Must have a parent dir");

        async {
            tokio::fs::create_dir_all(parent_dir).await?;
            let content = serde_json::to_string_pretty(receipt)
                .or_bug("Serializing deployment receipt to json");
            tokio::fs::write(&path, content).await?;
            Ok(())
        }
        .await
        .map_err(|e| WrapperError::IOError(path.clone(), e))
        .map_err(|e| CubistSdkError::SaveDeploymentReceiptError(path.clone(), Box::new(e)))?;

        debug!("Saved deployment receipt to {}", path.display());
        Ok(())
    }

    async fn find_receipts(&self, contract: &ContractFQN) -> Result<Vec<TransactionReceipt>> {
        let dir = self.target_paths.deployment_receipts_dir(contract);
        if !dir.is_dir() {
            return Ok(vec![]);
        }
        let to_err = |e: WrapperError| {
            CubistSdkError::DeserializeDeploymentReceiptError(dir.clone(), Box::new(e))
        };
        let mut receipts = vec![];
        let mut read_result = tokio::fs::read_dir(&dir)
            .await
            .map_err(|e| WrapperError::IOError(dir.clone(), e))
            .map_err(to_err)?;
        while let Some(dir_ent) = read_result
            .next_entry()
            .await
            .map_err(|e| WrapperError::IOError(dir.clone(), e))
            .map_err(to_err)?
        {
            let rec_path = dir_ent.path();
            if !rec_path.is_file() {
                continue;
            }
            // we don't expect anything other than valid transaction receipt files in this dir
            let contents = tokio::fs::read_to_string(&rec_path)
                .await
                .map_err(|e| WrapperError::IOError(rec_path.clone(), e))
                .map_err(to_err)?;
            let tr = serde_json::from_str::<TransactionReceipt>(&contents)
                .map_err(|e| {
                    WrapperError::JsonError(
                        rec_path.to_path_buf(),
                        "TransactionReceipt".to_owned(),
                        e,
                    )
                })
                .map_err(to_err)?;
            debug!(
                "Found receipt '{}' for contract {contract}",
                rec_path.display()
            );
            receipts.push(tr);
        }
        Ok(receipts)
    }
}

/// Creates a new instance of a validator. A validator is used to check whether source files are
/// error free before they are handed off to the rest of our pipeline.
fn validator(
    compiler: &Compiler,
    compiler_config: &CompilerConfig,
) -> Result<Box<dyn ContractCompiler>> {
    match compiler {
        Compiler::Solc => Ok(Box::new(SolcCompiler::new_validator(compiler_config))),
        Compiler::Solang => todo!(),
        Compiler::Soroban => todo!(),
    }
}

/// Validates a source file.
pub fn validate_file(
    compiler: &Compiler,
    compiler_config: &CompilerConfig,
    file: &Path,
) -> Result<()> {
    validator(compiler, compiler_config)?.compile_file(file)?;
    Ok(())
}

fn to_http_scheme(scheme: &str) -> &str {
    match scheme {
        "ws" => "http",
        "wss" => "https",
        s => s,
    }
}

fn to_ws_scheme(scheme: &str) -> &str {
    match scheme {
        "http" => "ws",
        "httpss" => "wss",
        s => s,
    }
}
