//! Auto-generated by Cubist. Do not edit manually.

#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(clippy::module_inception)]

use std::sync::Arc;
use lazy_static::lazy_static;
use ethers::{abi::{Tokenize, Address}, providers::Middleware};
use tokio::sync::OnceCell;

use cubist_config::{Config, Target};
use cubist_sdk::{core::{Cubist, Contract, ContractAddress, TargetProject}, Http, Ws, CubistSdkError};

pub type Result<T, E = CubistSdkError> = std::result::Result<T, E>;

{%- for c in evm_contracts %}
pub mod {{c.rs_mod_name}};
{% endfor %}

{%- for c in soroban_contracts %}
pub mod {{c.rs_mod_name}};
{% endfor %}

{%- for c in evm_contracts %}
/// Strongly-typed bindings for the '{{c.struct_name}}' contract's functions/events.
pub struct {{c.struct_name}}<M: Middleware = Http>({{c.rs_mod_name}}::{{c.struct_name}}<M>, Arc<Contract<M>>);
{% endfor %}

{%- for c in soroban_contracts %}
/// Strongly-typed bindings for the '{{c.struct_name}}' contract's functions/events.
pub struct {{c.struct_name}} {
  contract: Arc<Contract<Http>>,
}
{% endfor %}

lazy_static! {
    static ref CUBIST_CELL: OnceCell<Cubist<Http>> = OnceCell::new();
    static ref CUBIST_WS_CELL: OnceCell<Cubist<Ws>> = OnceCell::new();
}

/// Load 'cubist-config.json' from the root of the cargo project
pub fn load_config() -> Result<Config> {
    let config_path = format!("{}/cubist-config.json", env!("CARGO_MANIFEST_DIR"));
    Ok(Config::from_file(config_path)?)
}

/// Return the global [`Cubist`] instance that connects to the chain RPC endpoint over HTTP.
pub async fn cubist() -> Result<&'static Cubist> {
    CUBIST_CELL.get_or_try_init(new_cubist).await
}

/// Return the global [`Cubist`] instance that connects to the chain RPC endpoint over Web Sockets.
pub async fn cubist_ws() -> Result<&'static Cubist<Ws>> {
    CUBIST_WS_CELL.get_or_try_init(new_cubist_ws).await
}

/// Create a new [`Cubist`] instance over HTTP.
///
/// Contracts from different [`Cubist`] instances are deployable
/// independently of each other, whereas each contract returned by the
/// same [`Cubist`] instance can be deployed at most once.
pub async fn new_cubist() -> Result<Cubist> {
    let cfg = load_config()?;
    Cubist::<Http>::new(cfg).await
}

/// Create a new [`Cubist`] instance over Web Sockets.
///
/// Contracts from different [`Cubist`] instances are deployable
/// independently of each other, whereas each contract returned by the
/// same [`Cubist`] instance can be deployed at most once.
pub async fn new_cubist_ws() -> Result<Cubist<Ws>> {
    let cfg = load_config()?;
    Cubist::<Ws>::new(cfg).await
}

/// Deployable contract.
///
/// # Type Parameters
/// - `M` : type of the middleware
/// - `T` : exact contract type 
pub struct Deployable<M: Middleware, T> {
    /// Underlying Cubist implementation
    contract: Arc<Contract<M>>,
    /// Factory function to use to produce a concrete contract of the exact type `T`
    factory: Box<dyn FnOnce(Address, Arc<M>) -> T>,
}

impl<M: Middleware, T> Deployable<M, T> {
    /// Deploy the contract.
    ///
    /// # Arguments
    /// - `constructor_args` : deployment arguments.  Must match the contract's constructor definition.
    pub async fn deploy<TArgs>(self, constructor_args: TArgs) -> Result<T>
    where
        TArgs: Tokenize,
    {
        let (address, client) = self.contract.deploy(constructor_args).await?;
        Ok((self.factory)(Address::from_slice(&address), client))
    }

    /// Deploy the shims for this contract.
    pub async fn deploy_shims(self) -> Result<Self> {
        self.contract.deploy_shims().await?;
        Ok(self)
    }

    /// Get the address of this contract on target chain `t`.
    pub fn addr(&self, t: Target) -> ContractAddress {
        self.contract.address_on(t)
    }

    /// Set address of this contract.  Returns an error if address is
    /// already set and is different from `addr`.
    pub fn at(self, address: Address) -> T {
        let client = self.contract.project.provider();
        (self.factory)(address, client)
    }

    /// Initialize this contract from its deployment receipt. No-op if already initialized.
    /// Succeeds only if there is exactly one corresponding deployment receipt found.
    pub async fn deployed(self) -> Result<T> {
        let address = self.contract.deployed().await?;
        let client = self.contract.project.provider();
        Ok((self.factory)(Address::from_slice(&address), client))
    }
}

/// Define additional helper methods for contract creation for type [`Cubist`].
pub trait CubistExt<M: Middleware> {
{%- for c in evm_contracts %}
    /// Creates a deployable instance of [`{{c.struct_name}}`]. Call `deploy` on it to actually deploy it.
    fn {{c.rs_mod_name}}(&self) -> Deployable<M, {{c.struct_name}}<M>>;
{% endfor %}
}

impl<M: Middleware + 'static> CubistExt<M> for Cubist<M> {
{%- for c in evm_contracts %}
    fn {{c.rs_mod_name}}(&self) -> Deployable<M, {{c.struct_name}}<M>> {
        let contract = self.contract("{{c.struct_name}}").expect("Contract '{{c.struct_name}}' not found");
        Deployable {
            contract: Arc::clone(&contract),
            factory: Box::new(|addr, client| {{c.struct_name}}({{c.rs_mod_name}}::{{c.struct_name}}::new(addr, client), contract)),
        }
    }
{% endfor %}
}

{%- for c in evm_contracts %}
impl {{c.struct_name}} {
    /// Creates and deploys a new instance of [`{{c.struct_name}}`].
    ///
    /// # Arguments
    /// - `constructor_args` : deployment arguments.  Must match the definition of the
    ///                        contract's constructor; otherwise the deployment will fail.
    pub async fn deploy<T>(constructor_args: T) -> Result<{{c.struct_name}}<Http>>
    where
        T: Tokenize + Send,
    {
        cubist().await?.{{c.rs_mod_name}}().deploy(constructor_args).await
    }

    /// Deploys all shims for [`{{c.struct_name}}`], but does not deploy the main contract yet.
    /// This is useful if you need to deploy shims in order to supply the shims' addresses
    /// as arguments to constructors.
    pub async fn deploy_shims() -> Result<Deployable<Http, {{c.struct_name}}<Http>>> {
        cubist().await?.{{c.rs_mod_name}}().deploy_shims().await
    }

    /// Target chain of this contract
    pub fn target() -> Target {
        Target::{{c.target}}
    }

    /// Set address of this contract.  Returns an error if address is
    /// already set and is different from `addr`.
    pub async fn at(address: Address) -> Result<{{c.struct_name}}<Http>> {
        Ok(cubist().await?.{{c.rs_mod_name}}().at(address))
    }

    /// Initialize this contract from its deployment receipt.
    /// Succeeds only if there is exactly one corresponding deployment
    /// receipt found.
    pub async fn deployed() -> Result<{{c.struct_name}}<Http>> {
        cubist().await?.{{c.rs_mod_name}}().deployed().await
    }
}

impl<M: Middleware> {{c.struct_name}}<M> {
    /// Address of this contract on a given chain.
    pub fn addr(&self, t: Target) -> Address {
        Address::from_slice(&self.1.address_on(t))
    }

    /// Get target project.
    pub fn project(&self) -> &TargetProject<M> {
        self.1.project.as_ref()
    }

    {%- for target in c.shim_targets %}
    /// Returns the deployment address of this contract on chain '{{target}}'.
    ///
    /// # Panics
    /// - if the contract has not been deployed yet
    pub fn {{target | lower}}_address(&self) -> ContractAddress {
        self.try_get_{{target | lower}}_address()
            .expect("Contract '{{c.struct_name}}' not yet deployed on '{{target}}'")
    }

    /// Returns the deployment address of this contract on chain '{{target}}'
    /// if the contract has been deployed or `None` otherwise.
    pub fn try_get_{{target | lower}}_address(&self) -> Option<ContractAddress> {
        self.1.try_address_on(Target::{{target}})
    }
    {% endfor %}
}

impl<M: Middleware> std::ops::Deref for {{c.struct_name}}<M> {
    type Target = {{c.rs_mod_name}}::{{c.struct_name}}<M>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

{% endfor %}

{%- for c in soroban_contracts %}
impl {{c.struct_name}} {
    /// Creates and deploys a new instance of [`{{c.struct_name}}`].
    ///
    /// # Arguments
    /// - `constructor_args` : deployment arguments.  Must match the definition of the
    ///                        contract's constructor; otherwise the deployment will fail.
    pub async fn deploy<T>(_: T) -> Result<ContractAddress>
    where
        T: Tokenize + Send,
    {
        let cubist = cubist().await?; 
        let contract = cubist.contract("{{c.struct_name}}").unwrap();
        let addr = cubist.deploy_soroban_contract(&contract)?;
        contract.deploy_shims().await?;
        contract.set_soroban_addr(&addr).await?;
        contract.save_deployment_manifest().await?;
        Ok(addr)
    }

    /// Target chain of this contract
    pub fn target() -> Target {
        Target::{{c.target}}
    }

    /// Get the address of this contract on target chain `t`.
    pub async fn addr(t: Target) -> ContractAddress {
        cubist().await.unwrap().contract("{{c.struct_name}}").unwrap().address_on(t)
    }
}
{% endfor %}
