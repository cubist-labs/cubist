import * as path from 'path';

import { mkdir, writeFile, rename, } from 'fs/promises';
import { statSync, } from 'fs';

import {
  Config,
  ContractName,
  PathBuf,
  PreCompileManifest,
  Target,
} from './config';
import { TargetProject, } from './internal';

import * as internal from './internal';
import { NamedContract, } from './internal/target_handler';

/** Contract address (string).
 * @group Core
 * */
export type ContractAddress = internal.ContractAddress;

/**
 * Account address (string)
 * @group Core
 * */
export type AccountAddress = internal.AccountAddress;

export * from './config';
/** @group Internal */
export * as internal from './internal';
/** @group Core */
export { BigNumber, } from './internal';
/** @group Internal */
export { solidity, } from './internal';
/**
 * Alias to ether.js' Contract.
 * @group Core
 * */
export type EthersContract = internal.Contract;
export { find_file, } from './utils';

/**
 * Fully qualified contracts name.
 * @group Internal
 * */
export interface ContractFQN {
  /** Name of the file where the contract is defined. */
  readonly file: PathBuf;
  /** Contract name. */
  readonly name: ContractName;
}

/** @internal Target and address of a deployed contract. */
export interface DeploymentInfo {
  /** Chain to which the contract was deployed */
  readonly target: Target;
  /** Contract address */
  readonly address: ContractAddress;
}

/** @internal Per-contract manifest generated by the deployer. */
export interface DeploymentManifest extends DeploymentInfo {
  /** Deployed contract */
  readonly contract: ContractFQN;
  /** All of its shims' deployment infos */
  readonly shims: DeploymentInfo[];
}

/** @internal Serializes given manifest to JSON and writes it to a file atomically
 * (which guarantees that the relayer reads it after it has been flushed).
 *
 * @param {DeploymentManifest} dm - the deployment manifest to save
 * @param {PathBuf} manifestPath - the location where to save it
 *  */
async function writeAtomic(dm: DeploymentManifest, manifestPath: PathBuf): Promise<void> {
  await mkdir(path.dirname(manifestPath), { recursive: true, });
  const tempPath = `${manifestPath}.tmp`;
  await writeFile(tempPath, JSON.stringify(dm, null, 2));
  await rename(tempPath, manifestPath);
}

/**
 * The {@link Cubist} is _the_ way to work with interface with your cubist
 * projects. This class abstracts over all contracts and contract factories.
 *
 * @example Create a new project to access contracts and their factories:
 *
 * ```typescript
 * const cubist = new Cubist();
 * // get contract factory
 * const Receiver = cubist.getContractFactory('Receiver');
 * // deploy Receiver, ...
 *
 * // get already deployed Sender contract
 * const senderInstance = cubist.getContract('Sender');
 *
 * // wait for bridge to spin up
 * assert(await cubist.whenBridged());
 * ```
 *
 * Beyond exposing project {@link Contract | contracts} (via {@link
 * getContract}) and {@link ContractFactory | contract factories} (via {@link
 * getContractFactory}), projects can wait for bridges (between contracts and
 * cross-chain shims they call) to start up with {@link whenBridged}.
 *
 * At build time, `cubist build` generates a `CubistORM` class that extends
 * {@link Cubist} with the project-specific factories (see [Overview](/jsdoc/)). This
 * means, in practice, you don't even need to use {@link getContract} and
 * {@link getContractFactory}.
 *
 * @example Create a new project to access contracts and their factories with
 * `CubistORM`:
 *
 * ```typescript
 * import { CubistORM, } from '../build/orm/index.js';
 *
 * const cubist = new CubistORM();
 * // get contract factory
 * const Receiver = cubist.Receiver;
 * // deploy Receiver, ...
 *
 * // get already deployed Sender contract
 * const senderInstance = cubist.Sender.attach();
 *
 * // wait for bridge to spin up
 * assert(await cubist.whenBridged());
 * ```
 * @group Core
 */
export class Cubist {
  /** Underlying configuration. */
  public readonly config: Config;
  // Internal maps to keep track of contract names and their target projects.
  // Every target in the contractMap and shimMap has a corresponding entry in
  // the targetMap; we fail in the constructor if this is not the case.
  private readonly targetMap: Map<Target, TargetProject>;
  private readonly contractMap: Map<ContractName, Target>;
  private readonly shimMap: Map<ContractName, Set<Target>>;
  private readonly deps: Map<ContractName, Set<ContractName>>;
  private _initialized: boolean;

  /** Create new project. The constructor looks for the nearest
   * `cubist-config.json`, i.e., it looks in the current directory and every
   * parent directory until it finds the config.
   *
   * If the code using this SDK is not in the same directory tree, though, you
   * can pass an explicit config:
   *
   * ```typescript
   * const config = new Config('/path/to/your/cubist-config.json');
   * const cubist = new Cubist (config);
   * ```
   *
   * In the future this argument might change, e.g., to a filename instead of
   * explicit {@link Config}.
   *
   * @param {Config?} config - Optional config (using near otherwise).
   * */
  constructor(config?: Config) {
    this.config = config ?? Config.nearest();
    this.targetMap = new Map();
    this.contractMap = new Map();
    this.shimMap = new Map();
    this.deps = new Map();
    this._initialized = false; // we lazily initialize the maps
  }

  /**
   * @internal Finish initializing the instance by loading the contract and
   * shim maps.
   */
  private lazyInitialize() {
    if (this._initialized) {
      return;
    }
    // initialize the maps
    const build_dir = this.config.build_dir();
    for (const target of this.config.targets()) {
      this.targetMap.set(target, new TargetProject(target, this.config));

      // Read all pre-compile manifest files for the target chain
      const manifest_file =
        path.join(build_dir, target, 'contracts', 'cubist-manifest.json');
      const manifest: PreCompileManifest =
        PreCompileManifest.from_file(manifest_file);
      manifest.files.forEach((file) => {
        if (file.is_shim) {
          // This is a generated file
          for (const contractName of Object.keys(file.contract_dependencies)) {
            if (this.shimMap.has(contractName)) {
              this.shimMap.get(contractName).add(target);
            } else {
              this.shimMap.set(contractName, new Set([target]));
            }
          }
        } else {
          // This is a file with native contracts
          //   -> add each contract to the contractMap
          //   -> save its dependencies
          for (const contractName of Object.keys(file.contract_dependencies)) {
            const maybeTarget = this.contractMap.get(contractName);
            if (maybeTarget && maybeTarget != target) {
              throw new Error(`Unsupported: Contract ${contractName} defined across multiple targets.`);
            }
            this.contractMap.set(contractName, target);
            this.deps.set(contractName, new Set(file.contract_dependencies[contractName]));
          }
        }
      });
    }
    // done initializing!
    this._initialized = true;
  }

  /** Get contract factory given the contract name.
  * @param {ContractName} name - The contract name.
  * @return {ContractFactory} The contract factory.
  * */
  getContractFactory<T extends internal.Contract>(name: ContractName): ContractFactory<T> {
    this.lazyInitialize();
    // Get the native contract factory
    const contractTarget = this.contractMap.get(name);
    if (!contractTarget) {
      throw new Error(`Contract factory ${name} not found`);
    }
    const contractProject: TargetProject = this.targetMap.get(contractTarget);
    const contractFactory = contractProject.getContractFactory(name);

    // Get shim contract factory (might be on zero or many chains)
    const shimFactoryMap = new Map<Target, internal.ContractFactory>();
    const shimTargets = this.shimMap.get(name);
    if (shimTargets) {
      for (const shimTarget of shimTargets) {
        const shimProject: TargetProject = this.targetMap.get(shimTarget);
        const shimFactory = shimProject.getContractFactory(name);
        shimFactoryMap.set(shimTarget, shimFactory);
      }
    }
    const shimDeps = this.deps.get(name);
    return new ContractFactory<T>(name, this, contractProject, contractFactory, shimFactoryMap,
      shimDeps);
  }

  /** Get an existing deployed contract. This method looks up the contract's
   * deploy receipts in the `deploy` directory unless you explicitly tell it to
   * `ignoreReceipt`s (e.g., because you're trying to get a contract deployed
   * with another tool).
   *
   * **NOTE:** For now we only support deploying a contract once so calling
   * `getContract` with the same name but different addresses is not yet
   * supported.
   *
   * @param {ContractName} name - The contract name.
   * @param {ContractAddress?} addr - Optional contract address (if more than
   * one contract with same name).
   * @param {boolean} ignoreReceipt - Ignore receipt (e.g., if contract deployed
   * with another tool).
   * @return {Contract<T>} The contract.
   * @throws {Error} If the contract could not be found, if there are multiple
   * contracts and the address argument is omitted, or if the receipt is missing
   * (unless ignoreReceipt is set).
   * */
  getContract<T extends internal.Contract>(name: ContractName,
    addr?: ContractAddress, ignoreReceipt = false): Contract<T> {
    this.lazyInitialize();
    // Get the native contract
    const contractTarget = this.contractMap.get(name);
    if (!contractTarget) {
      throw new Error(`Could not find contract factory for ${name}`);
    }
    const contractProject: TargetProject = this.targetMap.get(contractTarget);
    const contract: NamedContract = contractProject.getNamedContract(name, addr, ignoreReceipt);

    // Get shim contract (might be on zero or many chains)
    const shimMap = new Map<Target, internal.Contract>();
    const shimTargets = this.shimMap.get(name);
    if (shimTargets) {
      for (const shimTarget of shimTargets) {
        const shimProject: TargetProject = this.targetMap.get(shimTarget);
        // TODO(Issue #580): once we have proper support for multiple instances
        // of the same contract we need to get the address of the shim
        // corresponding to `contract`.
        const fqnShim: NamedContract = shimProject.getNamedContract(name, undefined, ignoreReceipt);
        shimMap.set(shimTarget, fqnShim.inner);
      }
    }
    return new Contract(contractProject, contract.fqn, contract.inner, shimMap) as Contract<T>;
  }

  /**
   * Returns a promise that completes once bridges have been established for
   * all contracts in this projects.
   *
   * @param {number} retries - how many times to check
   * @param {number} delayMs - delay in milliseconds between checks
   * @return {boolean} - true if all bridges have been established
   * @throws {Error} if any contract in this project has not been deployed
   */
  public async whenBridged(retries = 100, delayMs = 100): Promise<boolean> {
    this.lazyInitialize();
    for (const contractName of this.contractMap.keys()) {
      const contract = this.getContract(contractName);
      const ok = await contract.whenBridged(retries, delayMs);
      if (!ok) {
        return false;
      }
    }
    return true;
  }
}

/**
 * Contract factories are used to create {@link Contract}s that span multiple
 * chains. Specifically, with a factory you can use:
 *
 * - {@link deploy} to deploy a {@link Contract} to its native target chain _and_
 *   automatically deploy its shims to the chains where this contract gets
 *   called.
 * - {@link deployShims} to deploy only the shims of the contract on all the
 *   chains the contract is called.
 * - {@link deployWithShims} to deploy the contract to its native target chain
 *   (given its already deployed shims). Together, {@link deployShims} and
 *   {@link deployWithShims}, make it possible to deploy shims before the
 *   native contract.
 * - {@link attach} to attach to an already deployed contract. This is the same
 *   as {@link Cubist.getContract}. We expose {@link attach} because the well-typed
 *   {@link Cubist} interface we generate at build time (with `cubist
 *   build`)---`CubistORM`---exports the project factories as properties on the
 *   object, avoiding the need to use `getContractFactory` and `getContract`.
 *
 * @example
 * Get factory and deploy contract and its shims with {@link Cubist}.
 * ```typescript
 * const StorageReceiver = cubist.getContractFactory('StorageReceiver');
 * const receiver = await StorageReceiver.deploy(33);
 * ```

 * @example
 * Get factory and attach to existing deployed contract.
 * ```typescript
 * import { CubistORM, } from '../build/orm/index.js';
 * // ...
 * const StorageReceiver = cubist.StorageReceiver;
 * const receiver = StorageReceiver.attach();
 * ```
 *
 * @group Core
 * */
export class ContractFactory<T extends internal.Contract> {
  private readonly name: ContractName;
  private readonly cubist: Cubist;
  private readonly internalFactory: internal.ContractFactory;
  private readonly shimFactoryMap: Map<Target, internal.ContractFactory>;
  private readonly shimDeps: Set<ContractName>;

  /** Underlying target project. */
  public readonly project: TargetProject;

  /** @internal Create new contract factory. The constructor is not intended to be called
   * directly. Use `getContractFactory` from the `Cubist` class instead.
   * @param {ContractName} name - The contract name.
   * @param {Cubist} cubist - The parent cubist project.
   * @param {TargetProject} project - The target chain project.
   * @param {internal.ContractFactory} internalFactory - The underlying contract factory.
   * @param {Map<Target, internal.ContractFactory>} shimFactoryMap - Map of shim contract factories.
   * @param {Set<ContractName>} shimDeps - Shims on this chain that this contract may call.
    */
  constructor(name: ContractName, cubist: Cubist,
    project: TargetProject,
    internalFactory: internal.ContractFactory,
    shimFactoryMap: Map<Target, internal.ContractFactory>,
    shimDeps: Set<ContractName>) {
    this.name = name;
    this.cubist = cubist;
    this.project = project;
    this.internalFactory = internalFactory;
    this.shimFactoryMap = shimFactoryMap;
    this.shimDeps = shimDeps;
  }

  /** Deploy contract and its shims.
   * This function deploys the contract to its target chain, and the shims to
   * their corresponding chains. We return a contract that encapsulates an
   * inner [ethers.js
   * Contract](https://docs.ethers.org/v5/api/contract/contract/) and exposes
   * some additional methods for interacting with the shims.
   *
   * **NOTE:** For now, you can only deploy a single instance of a contract.
   * The next release of cubist will have support for multiple instances (Issue
   * #580).
   *
   * @param {any[]} args - Arguments to call contract constructor with.
   * @return {Promise<Contract>} The deployed contract.
   * */
  async deploy(...args: any[]): // eslint-disable-line @typescript-eslint/no-explicit-any
    Promise<Contract<T>> {
    if (this.project.isDeployed(this.name)) {
      throw new Error(`${this.name} was already deployed. Multiple deployments coming soon.`);
    }
    // deploy shims
    const shims = await this.deployShims();
    // deploy native contract
    return this.deployWithShims(shims, ...args);
  }

  /** Deploy contract given the already-deployed shims.
   * This function deploys the {@link Contract} to its native target chain.
   * The first argument is the return value from the {@link deployShims} function.
   * The rest of the arguments are the constructor arguments.
   *
   * This function is useful for deploying cross-chain contracts that mutually
   * depend on each other.
   *
   * @param {Map<Target, T>} shims - the previously deployed shims.
   * @param {any[]} args - Arguments to pass to call contract constructor with.
   * @return {Promise<Contract>} The deployed contract.
   * */
  async deployWithShims(shims: Map<Target, T>,
    ...args: any[]): // eslint-disable-line @typescript-eslint/no-explicit-any
    Promise<Contract<T>> {
    if (this.project.isDeployed(this.name)) {
      throw new Error(`${this.name} was already deployed. Multiple deployments coming soon.`);
    }
    // deploy native contract
    const nativeContract = await this.internalFactory.deploy(...args);

    // for each dependency: make sure it's deployed (`getContract` throws
    // otherwise), and then call `approveCaller`
    for (const depName of this.shimDeps) {
      const depShim: internal.Contract = this.project.getContract(depName);
      // TODO (Issue #513): Consider passing number of confirmations to `wait`
      // according to the target chain properties.
      await (await depShim.approveCaller(nativeContract.address)).wait();
    }

    const c = new Contract(this.project, this.internalFactory.fqn(), nativeContract, shims);
    await c.saveDeploymentManifest();
    return c as Contract<T>;
  }

  /** Deploy shims for this contract. In some cases you need to deploy the
   * contract shims before the contract itself (see our TokenBridge for an
   * example). This method is used to do deploy the shims, which you can then
   * use when deploying the contract itself with {@link deployWithShims}.
   *
   * @example In our TokenBridge template (`cubist new --template TokenBridge`)
   * we set up a two way bridge across two chains and need to deploy shims on
   * one end to handle the circular dependency---the two contracts mutually
   * depend on each other.
   *
   * ```typescript
   * // deploy ERC20Bridged shims
   * const erc20bShims = await ERC20Bridged.deployShims();
   * // get the shim contract on the token sender chain
   * const erc20BridgedShim = erc20bShims.get(TokenSender.target());
   * // deploy the token sender contract and its shim
   * const tokenSender = await TokenSender.deploy(erc20BridgedShim.address);
   * // Deploy ERC20Bridged with the TokenSender address.
   * const erc20Bridged = await ERC20Bridged.deployWithShims(erc20bShims,
   * ```
   * @return {Promise<Map<Target, T>>} The deployed shims.
   */
  async deployShims(): Promise<Map<Target, T>> {
    const shims = new Map();
    // deploy shims
    for (const target of this.shimFactoryMap.keys()) {
      const shimContract = await this.deployShim(target);
      shims.set(target, shimContract);
    }
    return shims;
  }

  /** Get the already-deployed contract.
   * @return {Promise<Contract>} The deployed contract.
   */
  async deployed(): Promise<Contract<T>> {
    return this.cubist.getContract(this.name);
  }

  /** Get the already-deployed contract at particular address.
   * @param {ContractAddress} addr - Contract address.
   * @return {Promise<Contract>} The deployed contract.
   */
  async attach(addr: ContractAddress): Promise<Contract<T>> {
    return this.cubist.getContract(this.name, addr);
  }

  /** Deploy shim contract.
   * @param {Target} target - The target chain to deploy shim to.
   * @return {Promise<internal.Contract>} The deployed contract.
   * */
  private async deployShim(target: Target): Promise<internal.Contract> {
    const shimFactory = this.shimFactoryMap.get(target);
    if (!shimFactory) {
      throw new Error(`Contract not compiled for ${target}`);
    }
    // For now shim constructors don't take any arguments. This might change in
    // the future. See issue #423.
    const contract = await shimFactory.deploy();
    return contract;
  }

  /** Get (native) target chain.
   * @return {Target} The target chain.
   * */
  target(): Target {
    return this.project.target();
  }
}

/**
 * Multi-chain contract abstraction. Each Cubist contract encapsulates (for
 * now) an [ethers.js
 * Contract](https://docs.ethers.org/v5/api/contract/contract/)) that runs on a
 * _native target chain_ and zero or more _shim contracts_ running on other
 * chains.
 *
 * A contract deployed with {@link ContractFactory} is deployed to the chain
 * specified in the `cubist-config.json` configuration file; this is the native
 * target chain. If this contract is called on another chain, we also deploy
 * a _shim_ for this contract on that chain (either automatically when you use
 * {@link ContractFactory.deploy} or manually when you use
 * {@link ContractFactory.deployShims}).
 *
 * This class exposes the contract on the native target chains (via {@link
 * inner}), and several methods for getting the contract {@link target} chain,
 * its {@link address} on the native target chain, and its shims' {@link
 * addressOn | addresses on} other chains.
 *
 * @example ERC20 bridged from Avalanche to Polygon and Ethereum has a native
 * contract on Avalanche and corresponding shims on the other two chains.
 *
 * ```typescript
 * // ...
 * const cubist = new Cubist();
 * // get contract
 * const e20Bridged = cubist.getContract('ERC20Bridged');
 * // print its address on native chain
 * console.log(`address on ${e20Bridged.target()}: ${e20Bridged.address()}`);
 * // print its shims' addresses
 * console.log(`address on Polygon: ${e20Bridged.addressOn(Target.Polygon)}`);
 * console.log(`address on Ethereum: ${e20Bridged.addressOn(Target.Ethereum)}`);
 * ```
 *
 * @group Core
 * */
export class Contract<T extends internal.Contract> {
  /** The single-chain target project corresponding to the target chain this
   * contract was deployed to. In general you don't need to access the project
  * itself. */
  public readonly project: TargetProject;

  /** Fully qualified contract name. */
  public readonly fqn: ContractFQN;

  /**
   * The underlying (for now
   * [ethers.js](https://docs.ethers.org/v5/api/contract/contract/)) native
   * contract. This is ultimately the contract you will invoke methods on,
   * listen for events on, etc.
   * */
  public readonly inner: T;

  /** Any shims that may be defined for other chains. */
  private readonly shims: Map<Target, internal.Contract>;

  /** @return {Target} - The target chain the contract was deployed to. */
  public target(): Target {
    return this.project.target();
  }

  /** @internal Create new contract. The constructor is not intended to be called
   * directly. Use {@link Cubist.getContract} instead (or get a
   * contract by {@link deploy}ing it via a factory).
   * @param {TargetProject} target - The target chain project.
   * @param {ContractFQN} fqn - The contract fully qualified name.
   * @param {T} inner - The underlying contract.
   * @param {Map<Target, internal.Contract>} shims - Map of shim contracts.
   */
  constructor(target: TargetProject, fqn: ContractFQN, inner: T,
    shims: Map<Target, internal.Contract>) {
    this.project = target;
    this.fqn = fqn;
    this.inner = inner;
    this.shims = shims;
  }

  /** Get contract address of this contract on a particular target chain.
   * @param {Target} target - The target chain.
   * @return {ContractAddress} The contract address.
   */
  public addressOn(target: Target): ContractAddress {
    if (target == this.project.target()) {
      return this.inner.address;
    } else {
      const maybeShim = this.shims.get(target);
      if (maybeShim) {
        return maybeShim.address;
      }
      throw new Error(`Contract not deployed on ${target}`);
    }
  }

  /** Get contract address on the native target chain.
   * @return {ContractAddress} The contract address.
   */
  public address(): ContractAddress {
    return this.addressOn(this.project.target());
  }

  /**
   * Returns a promise that completes once the bridge between this contract and
   * its shims has been established. In general, you don't need to call this
   * yourself; the top-level {@link Cubist.whenBridged} does this for all contracts.
   *
   * @param {number} retries - how many times to check if the bridge has been established.
   * @param {number} delayMs - delay in milliseconds between retries.
   * @return {boolean} - whether a bridge has been established within the given time parameters.
   */
  public async whenBridged(retries = 100, delayMs = 100): Promise<boolean> {
    // contracts without shims need no bridging
    if (this.shims.size == 0) {
      return true;
    }

    const tryIsFile = (p: PathBuf) => {
      try {
        return statSync(p).isFile();
      } catch {
        return false;
      }
    };

    const bridgedPath = this.deploymentManifestBridgedPath();
    for (let i = 0; i < retries; i++) {
      if (tryIsFile(bridgedPath)) {
        return true;
      }
      await new Promise((r) => setTimeout(r, delayMs));
    }
    return false;
  }

  /**
   * @internal
   * Creates a manifest for this contract and saves it to disk (in the {@link
   * Config.deploy_dir} directory).
   */
  async saveDeploymentManifest() {
    const dm = <DeploymentManifest> {
      contract: this.fqn,
      target: this.project.target(),
      address: this.inner.address,
      shims: [...this.shims].map((x) => <DeploymentInfo>{
        target: x[0],
        address: x[1].address,
      }),
    };

    // Manifest path: deploy/cubist-deploy/{contract_name}-{address}.json
    const manifestPath = this.deploymentManifestPath();
    await writeAtomic(dm, manifestPath);
  }

  /** @internal
   * @return {PathBuf} - Directory where deployment manifest files are to be written.
   * */
  deploymentManifestDir(): PathBuf {
    return path.join(this.project.config.deploy_dir(), 'cubist-deploy');
  }

  /** @internal
   * @return {PathBuf} - File stem of the deployment manifest file
   * */
  deploymentManifestStem(): string {
    return `${this.fqn.name}-${this.inner.address}`;
  }

  /** @internal
   * @return {PathBuf} - Full path to the deployment manifest file
   * */
  deploymentManifestPath(): PathBuf {
    return path.join(this.deploymentManifestDir(), `${this.deploymentManifestStem()}.json`);
  }

  /** @internal
   * @return {PathBuf} - Full path to the file indicating that the deployment
   * has been bridged
   * */
  deploymentManifestBridgedPath(): PathBuf {
    return path.join(this.deploymentManifestDir(), `${this.deploymentManifestStem()}.bridged`);
  }
}
