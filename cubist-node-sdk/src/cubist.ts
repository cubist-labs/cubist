import * as path from 'path';

import { mkdir, writeFile, rename, } from 'fs/promises';
import { statSync, } from 'fs';

import {
  Config,
  ContractName,
  PathBuf,
  PreCompileManifest,
  Target,
} from './config';
import { TargetProject, } from './internal';

import * as internal from './internal';
import { NamedContract, } from './internal/target_handler';

// export type ContractFactory = internal.ContractFactory;
export type ContractAddress = internal.ContractAddress;
export type AccountAddress = internal.AccountAddress;

export * from './config';
export * as internal from './internal';
export { solidity, BigNumber, } from './internal';
export type EthersContract = internal.Contract;
export { find_file, } from './utils';

/** Fully qualified contracts name. */
export class ContractFQN {
  /** Name of the file where the contract is defined. */
  public readonly file: PathBuf;
  /** Contract name. */
  public readonly name: ContractName;
}

/** @internal Target and address of a deployed contract. */
export class DeploymentInfo {
  /** Chain to which the contract was deployed */
  public readonly target: Target;
  /** Contract address */
  public readonly address: ContractAddress;
}

/** @internal Per-contract manifest generated by the deployer. */
export class DeploymentManifest extends DeploymentInfo {
  /** Deployed contract */
  public readonly contract: ContractFQN;
  /** All of its shims' deployment infos */
  public readonly shims: DeploymentInfo[];
}

/** @internal Serializes given manifest to JSON and writes it to a file atomically
 * (which guarantees that the relayer reads it after it has been flushed).
 *
 * @param {DeploymentManifest} dm - the deployment manifest to save
 * @param {PathBuf} manifestPath - the location where to save it
 *  */
async function writeAtomic(dm: DeploymentManifest, manifestPath: PathBuf): Promise<void> {
  await mkdir(path.dirname(manifestPath), { recursive: true, });
  const tempPath = `${manifestPath}.tmp`;
  await writeFile(tempPath, JSON.stringify(dm, null, 2));
  await rename(tempPath, manifestPath);
}

/**
 * Project encapsulating all contracts and contract factories for a particular
 * target chain.
 */
export class Cubist {
  public readonly config: Config;
  // Internal maps to keep track of contract names and their target projects.
  // Every target in the contractMap and shimMap has a corresponding entry in
  // the targetMap; we fail in the constructor if this is not the case.
  private readonly targetMap: Map<Target, TargetProject>;
  private readonly contractMap: Map<ContractName, Target>;
  private readonly shimMap: Map<ContractName, Set<Target>>;
  private readonly deps: Map<ContractName, Set<ContractName>>;
  private _initialized: boolean;

  /** Create new project per target
   * @param {Config?} config - Optional config (using near otherwise).
   */
  constructor(config?: Config) {
    this.config = config ?? Config.nearest();
    this.targetMap = new Map();
    this.contractMap = new Map();
    this.shimMap = new Map();
    this.deps = new Map();
    this._initialized = false; // we lazily initialize the maps
  }

  /**
   * Finish initializing the instance by loading the contract and shim maps.
   */
  lazyInitialize() {
    if (this._initialized) {
      return;
    }
    // initialize the maps
    const build_dir = this.config.build_dir();
    for (const target of this.config.targets()) {
      this.targetMap.set(target, new TargetProject(target, this.config));

      // Read all pre-compile manifest files for the target chain
      const manifest_file =
        path.join(build_dir, target, 'contracts', 'cubist-manifest.json');
      const manifest: PreCompileManifest =
        PreCompileManifest.from_file(manifest_file);
      manifest.files.forEach((file) => {
        if (file.is_shim) {
          // This is a generated file
          for (const contractName of Object.keys(file.contract_dependencies)) {
            if (this.shimMap.has(contractName)) {
              this.shimMap.get(contractName).add(target);
            } else {
              this.shimMap.set(contractName, new Set([target]));
            }
          }
        } else {
          // This is a file with native contracts
          //   -> add each contract to the contractMap
          //   -> save its dependencies
          for (const contractName of Object.keys(file.contract_dependencies)) {
            const maybeTarget = this.contractMap.get(contractName);
            if (maybeTarget && maybeTarget != target) {
              throw new Error(`Unsupported: Contract ${contractName} defined across multiple targets.`);
            }
            this.contractMap.set(contractName, target);
            this.deps.set(contractName, new Set(file.contract_dependencies[contractName]));
          }
        }
      });
    }
    // done initializing!
    this._initialized = true;
  }

  /** Get contract factory.
  * @param {ContractName} name - The contract name.
  * @return {ContractFactory} The contract factory.
  * */
  getContractFactory<T extends internal.Contract>(name: ContractName): ContractFactory<T> {
    this.lazyInitialize();
    // Get the native contract factory
    const contractTarget = this.contractMap.get(name);
    if (!contractTarget) {
      throw new Error(`Contract factory ${name} not found`);
    }
    const contractProject: TargetProject = this.targetMap.get(contractTarget);
    const contractFactory = contractProject.getContractFactory(name);

    // Get shim contract factory (might be on zero or many chains)
    const shimFactoryMap = new Map<Target, internal.ContractFactory>();
    const shimTargets = this.shimMap.get(name);
    if (shimTargets) {
      for (const shimTarget of shimTargets) {
        const shimProject: TargetProject = this.targetMap.get(shimTarget);
        const shimFactory = shimProject.getContractFactory(name);
        shimFactoryMap.set(shimTarget, shimFactory);
      }
    }
    const shimDeps = this.deps.get(name);
    return new ContractFactory<T>(name, this, contractProject, contractFactory, shimFactoryMap,
      shimDeps);
  }

  /** Get deployed contract.
  * @param {ContractName} name - The contract name.
  * @param {ContractAddress?} addr - Optional contract address (if more than
  * one contract with same name).
  * @param {boolean} ignoreReceipt - Ignore receipt (e.g., if contract deployed
  * with another tool).
  * @return {Contract<T>} The contract.
  * @throws {Error} If the contract could not be found, if there are multiple
  * contracts and the address argument is omitted, or if the receipt is missing
  * (unless ignoreReceipt is set).
  * */
  getContract<T extends internal.Contract>(name: ContractName,
    addr?: ContractAddress, ignoreReceipt = false): Contract<T> {
    this.lazyInitialize();
    // Get the native contract
    const contractTarget = this.contractMap.get(name);
    if (!contractTarget) {
      throw new Error(`Could not find contract factory for ${name}`);
    }
    const contractProject: TargetProject = this.targetMap.get(contractTarget);
    const contract: NamedContract = contractProject.getNamedContract(name, addr, ignoreReceipt);

    // Get shim contract (might be on zero or many chains)
    const shimMap = new Map<Target, internal.Contract>();
    const shimTargets = this.shimMap.get(name);
    if (shimTargets) {
      for (const shimTarget of shimTargets) {
        const shimProject: TargetProject = this.targetMap.get(shimTarget);
        // TODO(Issue #580): once we have proper support for multiple instances
        // of the same contract we need to get the address of the shim
        // corresponding to `contract`.
        const fqnShim: NamedContract = shimProject.getNamedContract(name, undefined, ignoreReceipt);
        shimMap.set(shimTarget, fqnShim.inner);
      }
    }
    return new Contract(contractProject, contract.fqn, contract.inner, shimMap) as Contract<T>;
  }

  /**
   * Returns a promise that completes once bridges have
   * been established for all contracts in this projects.
   *
   * @param {number} retries - how many times to check
   * @param {number} delayMs - delay in milliseconds between checks
   * @return {boolean} - whether all bridges have been established
   * @throws {Error} if any contract in this project has not been deployed
   */
  public async whenBridged(retries = 100, delayMs = 100): Promise<boolean> {
    this.lazyInitialize();
    for (const contractName of this.contractMap.keys()) {
      const contract = this.getContract(contractName);
      const ok = await contract.whenBridged(retries, delayMs);
      if (!ok) {
        return false;
      }
    }
    return true;
  }
}

/**
 * Contract factory for a particular target chain.
 */
export class ContractFactory<T extends internal.Contract> {
  private readonly name: ContractName;
  private readonly cubist: Cubist;
  private readonly internalFactory: internal.ContractFactory;
  private readonly shimFactoryMap: Map<Target, internal.ContractFactory>;
  private readonly shimDeps: Set<ContractName>;

  /** Underlying target project. */
  public readonly project: TargetProject;

  /** Create new contract factory. The constructor is not intended to be called
   * directly. Use `getContractFactory` from the `Cubist` class instead.
   * @ignore
   * @param {ContractName} name - The contract name.
   * @param {Cubist} cubist - The parent cubist project.
   * @param {TargetProject} project - The target chain project.
   * @param {internal.ContractFactory} internalFactory - The underlying contract factory.
   * @param {Map<Target, internal.ContractFactory>} shimFactoryMap - Map of shim contract factories.
   * @param {Set<ContractName>} shimDeps - Shims on this chain that this contract may call.
    */
  constructor(name: ContractName, cubist: Cubist,
    project: TargetProject,
    internalFactory: internal.ContractFactory,
    shimFactoryMap: Map<Target, internal.ContractFactory>,
    shimDeps: Set<ContractName>) {
    this.name = name;
    this.cubist = cubist;
    this.project = project;
    this.internalFactory = internalFactory;
    this.shimFactoryMap = shimFactoryMap;
    this.shimDeps = shimDeps;
  }

  /** Deploy contract and its shims.
   * This function deploys the contract to its target chain, and the shims to
   * their corresponding chains. We return a contract that encapsulates an
   * inner ethers.js contract and exposes some additional methods for
   * interacting with the shims.
   *
   * For now, you can only deploy a single instance of a contract. The next
   * release of cubist will have support for multiple instances (Issue #580).
   *
   * @param {any[]} args - Arguments to call contract constructor with.
   * @return {Promise<Contract>} The deployed contract.
   * */
  async deploy(...args: any[]): // eslint-disable-line @typescript-eslint/no-explicit-any
    Promise<Contract<T>> {
    if (this.project.isDeployed(this.name)) {
      throw new Error(`${this.name} was already deployed. Multiple deployments coming soon.`);
    }
    // deploy shims
    const shims = await this.deployShims();
    // deploy native contract
    return this.deployWithShims(shims, ...args);
  }

  /** Deploy contract given the already-deployed shims.
   * This function deploys the contract to its target chain.
   * The first argument is the return value from the `deployShims` function.
   * We return a monkeypatched contract that
   * exposes some additional methods for interacting with the shims.
   * @param {Map<Target, T>} shims - the previously deployed shims.
   * @param {any[]} args - Arguments to pass to call contract constructor with.
   * @return {Promise<Contract>} The deployed contract.
   * */
  async deployWithShims(shims: Map<Target, T>,
    ...args: any[]): // eslint-disable-line @typescript-eslint/no-explicit-any
    Promise<Contract<T>> {
    if (this.project.isDeployed(this.name)) {
      throw new Error(`${this.name} was already deployed. Multiple deployments coming soon.`);
    }
    // deploy native contract
    const nativeContract = await this.internalFactory.deploy(...args);

    // for each dependency: make sure it's deployed (`getContract` throws
    // otherwise), and then call `approveCaller`
    for (const depName of this.shimDeps) {
      const depShim: internal.Contract = this.project.getContract(depName);
      // TODO (Issue #513): Consider passing number of confirmations to `wait`
      // according to the target chain properties.
      await (await depShim.approveCaller(nativeContract.address)).wait();
    }

    const c = new Contract(this.project, this.internalFactory.fqn(), nativeContract, shims);
    await c.saveDeploymentManifest();
    return c as Contract<T>;
  }

  /** Deploy shims for this contract.
   * This function deploys only the shims for the contract, returning the
   * deployed shims.
   * @return {Promise<Map<Target, T>>} The deployed shims.
   */
  async deployShims(): Promise<Map<Target, T>> {
    const shims = new Map();
    // deploy shims
    for (const target of this.shimFactoryMap.keys()) {
      const shimContract = await this.deployShim(target);
      shims.set(target, shimContract);
    }
    return shims;
  }

  /** Get the already-deployed contract.
   * @return {Promise<Contract>} The deployed contract.
   */
  async deployed(): Promise<Contract<T>> {
    return this.cubist.getContract(this.name);
  }

  /** Get the already-deployed contract at particular address.
   * @param {ContractAddress} addr - Contract address.
   * @return {Promise<Contract>} The deployed contract.
   */
  async attach(addr: ContractAddress): Promise<Contract<T>> {
    return this.cubist.getContract(this.name, addr);
  }

  /** Deploy shim contract.
   * @param {Target} target - The target chain to deploy shim to.
   * @return {Promise<internal.Contract>} The deployed contract.
   * */
  private async deployShim(target: Target): Promise<internal.Contract> {
    const shimFactory = this.shimFactoryMap.get(target);
    if (!shimFactory) {
      throw new Error(`Contract not compiled for ${target}`);
    }
    // For now shim constructors don't take any arguments. This might change in
    // the future. See issue #423.
    const contract = await shimFactory.deploy();
    return contract;
  }

  /** Get (native) target chain.
   * @return {Target} The target chain.
   * */
  target(): Target {
    return this.project.target();
  }
}

/**
 * Contract for a particular target chain.
 */
export class Contract<T extends internal.Contract> {
  /** The native target chain project. */
  private readonly project: TargetProject;
  /** Fully qualified name. */
  public readonly fqn: ContractFQN;
  /** The underling native contract. */
  public readonly inner: T;
  /** Any shims that may be defined for other chains. */
  private readonly shims: Map<Target, internal.Contract>;

  /** @return {Target} - The target chain */
  public target(): Target {
    return this.project.target();
  }

  /** Create new contract. The constructor is not intended to be called
   * directly. Use {@link Cubist.getContract} instead (or get a
   * contract by {@link deploy}ing it via a factory).
   * @internal
   * @param {TargetProject} target - The target chain project.
   * @param {ContractFQN} fqn - The contract fully qualified name.
   * @param {T} inner - The underlying contract.
   * @param {Map<Target, internal.Contract>} shims - Map of shim contracts.
   */
  constructor(target: TargetProject, fqn: ContractFQN, inner: T,
    shims: Map<Target, internal.Contract>) {
    this.project = target;
    this.fqn = fqn;
    this.inner = inner;
    this.shims = shims;
  }

  /** Get contract address on target chain.
   * @param {Target} target - The target chain.
   * @return {ContractAddress} The contract address.
   */
  public addressOn(target: Target): ContractAddress {
    if (target == this.project.target()) {
      return this.inner.address;
    } else {
      const maybeShim = this.shims.get(target);
      if (maybeShim) {
        return maybeShim.address;
      }
      throw new Error(`Contract not deployed on ${target}`);
    }
  }

  /** Get contract address on native target chain.
   * @return {ContractAddress} The contract address.
   */
  public address(): ContractAddress {
    return this.addressOn(this.project.target());
  }

  /**
   * Returns a promise that completes once the bridge between
   * this contract and its shims has been established.
   *
   * @param {number} retries - how many times to check if the bridge has been established.
   * @param {number} delayMs - delay in milliseconds between retries.
   * @return {boolean} - whether a bridge has been established within the given time parameters.
   */
  public async whenBridged(retries = 100, delayMs = 100): Promise<boolean> {
    // contracts without shims need no bridging
    if (this.shims.size == 0) {
      return true;
    }

    const tryIsFile = (p: PathBuf) => {
      try {
        return statSync(p).isFile();
      } catch {
        return false;
      }
    };

    const bridgedPath = this.deploymentManifestBridgedPath();
    for (let i = 0; i < retries; i++) {
      if (tryIsFile(bridgedPath)) {
        return true;
      }
      await new Promise((r) => setTimeout(r, delayMs));
    }
    return false;
  }

  /**
   * Creates a manifest for this contract and saves it to disk (in the {@link
   * Config.deploy_dir} directory).
   */
  async saveDeploymentManifest() {
    const dm = <DeploymentManifest> {
      contract: this.fqn,
      target: this.project.target(),
      address: this.inner.address,
      shims: [...this.shims].map((x) => <DeploymentInfo>{
        target: x[0],
        address: x[1].address,
      }),
    };

    // Manifest path: deploy/cubist-deploy/{contract_name}-{address}.json
    const manifestPath = this.deploymentManifestPath();
    await writeAtomic(dm, manifestPath);
  }

  /** @return {PathBuf} - Directory where deployment manifest files are to be written. */
  deploymentManifestDir(): PathBuf {
    return path.join(this.project.config.deploy_dir(), 'cubist-deploy');
  }

  /** @return {PathBuf} - File stem of the deployment manifest file */
  deploymentManifestStem(): string {
    return `${this.fqn.name}-${this.inner.address}`;
  }

  /** @return {PathBuf} - Full path to the deployment manifest file */
  deploymentManifestPath(): PathBuf {
    return path.join(this.deploymentManifestDir(), `${this.deploymentManifestStem()}.json`);
  }

  /** @return {PathBuf} - Full path to the file indicating that the deployment
  * has been bridged */
  deploymentManifestBridgedPath(): PathBuf {
    return path.join(this.deploymentManifestDir(), `${this.deploymentManifestStem()}.bridged`);
  }
}
