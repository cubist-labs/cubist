/**
 * This module exports a simple interface for working with Cubist projects and
 * their smart contracts:
 *
 *   - {@link Cubist} abstracts over cubist projects and is _the_ way to access
 *   {@link Contract | contracts} and {@link ContractFactory | contract
 *   factories}.
 *   - {@link ContractFactory} is for deploying contracts and contract shims.
 *   - {@link Contract} is for interacting with deployed contracts.
 *
 * It also re-exports several references and type definitions (e.g., {@link
 * BigNumber}).
 *
 * All these definitions are exposed at the top-level, so you can simply import
 * them as:
 *
 * ```typescript
 * import { Cubist, } from '@cubist-labs/cubist'
 *
 * // ...
 * async function main() {
 *   const cubist = new Cubist(); // create new project
 *   await cubist.getContractFactory('MyContract').deploy()
 *   // ...
 * }
 * ```
 *
 * :::note
 * We classify exports into two categories: core and internal. As a user, you
 * should not really need to use or think abot internals; we only include them
 * in the documentation because you might encounter them reading our code.
 * :::
 *
 *
 * @module
 */
import * as path from 'path';

import { mkdir, writeFile, rename, } from 'fs/promises';
import { statSync, } from 'fs';

import {
  BridgeProvider,
  Config,
  ContractName,
  PathBuf,
  PreCompileManifest,
  Target,
} from './config';
import { BigNumber, TargetProject, } from './internal';

import * as internal from './internal';
import { NamedContract, Signer, AccountAddressOrIndex, } from './internal/target_handler';

/** Contract address (string).
 * @group Core
 * */
export type ContractAddress = internal.ContractAddress;

/**
 * Account address (string)
 * @group Core
 * */
export type AccountAddress = internal.AccountAddress;

/**
 * Account or contract address (string)
 * @group Core
 * */
export type Address = internal.Address;

/** Account address or account index.
 * @group Core
 * */
export { AccountAddressOrIndex, } from './internal/target_handler';

/** Map from Target to account address or index.
 * @group Core
 * */
export type SignerMap = {
  [key in keyof typeof Target]?: AccountAddressOrIndex // eslint-disable-line no-unused-vars
};

export * from './config';
/** @group Internal */
export * as internal from './internal';
/** @group Core */
export { BigNumber, } from './internal';
/** @group Internal */
export { solidity, } from './internal';
/**
 * Alias to ether.js' Contract.
 * @group Core
 * */
export type EthersContract = internal.Contract;
/** @ignore */
export { find_file, } from './utils';

/**
 * Fully qualified contracts name.
 * @group Internal
 * */
export interface ContractFQN {
  /** Name of the file where the contract is defined. */
  readonly file: PathBuf;
  /** Contract name. */
  readonly name: ContractName;
}

/** @internal Target and address of a deployed contract. */
export interface DeploymentInfo {
  /** Chain to which the contract was deployed */
  readonly target: Target;
  /** Contract address */
  readonly address: ContractAddress;
}

/** @internal Per-contract manifest generated by the deployer. */
export interface DeploymentManifest extends DeploymentInfo {
  /** Deployed contract */
  readonly contract: ContractFQN;
  /** All of its shims' deployment infos */
  readonly shims: DeploymentInfo[];
}

/** @internal Serializes given manifest to JSON and writes it to a file atomically
 * (which guarantees that the relayer reads it after it has been flushed).
 *
 * @param {DeploymentManifest} dm - the deployment manifest to save
 * @param {PathBuf} manifestPath - the location where to save it
 *  */
async function writeAtomic(dm: DeploymentManifest, manifestPath: PathBuf): Promise<void> {
  await mkdir(path.dirname(manifestPath), { recursive: true, });
  const tempPath = `${manifestPath}.tmp`;
  await writeFile(tempPath, JSON.stringify(dm, null, 2));
  await rename(tempPath, manifestPath);
}

/**
 * This class is _the_ way to work with interface with your cubist
 * projects. This class abstracts over all contracts and contract factories.
 *
 * @example Create a new project to access contracts and their factories:
 *
 * ```typescript
 * const cubist = new Cubist();
 * // get contract factory
 * const Receiver = cubist.getContractFactory('Receiver');
 * // deploy Receiver, ...
 *
 * // get already deployed Sender contract
 * const senderInstance = cubist.getContract('Sender');
 *
 * // wait for bridge to spin up
 * assert(await cubist.whenBridged());
 * ```
 *
 * Beyond exposing project {@link Contract | contracts} (via {@link
 * getContract}) and {@link ContractFactory | contract factories} (via {@link
 * getContractFactory}), projects can wait for bridges (between contracts and
 * cross-chain shims they call) to start up with {@link whenBridged}.
 *
 * At build time, `cubist build` generates a [CubistORM] class that extends
 * {@link Cubist} with the project-specific factories (see
 * [Overview](/jsdoc/)). This means, in practice, you don't even need to use
 * {@link getContract} and {@link getContractFactory}.
 *
 * @example Create a new project to access contracts and their factories with [CubistORM]:
 *
 * ```typescript
 * import { CubistORM, } from '../build/orm/index.js';
 *
 * const cubist = new CubistORM();
 * // get contract factory
 * const Receiver = cubist.Receiver;
 * // deploy Receiver, ...
 *
 * // get already deployed Sender contract
 * const senderInstance = cubist.Sender.attach();
 *
 * // wait for bridge to spin up
 * assert(await cubist.whenBridged());
 * ```
 *
 * [CubistORM]: /jsdoc-md/cubist.CubistORM
 *
 * @group Core
 */
export class Cubist {
  /** Underlying configuration. */
  public readonly config: Config;
  // Internal maps to keep track of contract names and their target projects.
  // Every target in the contractMap and shimMap has a corresponding entry in
  // the targetMap; we fail in the constructor if this is not the case.
  private readonly targetMap: Map<Target, TargetProject>;
  private readonly contractMap: Map<ContractName, Target>;
  private readonly shimMap: Map<ContractName, Set<Target>>;
  private readonly deps: Map<ContractName, Set<ContractName>>;
  private _initialized: boolean;

  /** Create new project. The constructor looks for the nearest
   * `cubist-config.json`, i.e., it looks in the current directory and every
   * parent directory until it finds the config.
   *
   * If the code using this SDK is not in the same directory tree, though, you
   * can pass an explicit config:
   *
   * ```typescript
   * const config = new Config('/path/to/your/cubist-config.json');
   * const cubist = new Cubist (config);
   * ```
   *
   * In the future this argument might change, e.g., to a filename instead of
   * explicit {@link Config}.
   *
   * @param {Config?} config - Optional config (using near otherwise).
   * */
  constructor(config?: Config) {
    this.config = config ?? Config.nearest();
    this.targetMap = new Map();
    this.contractMap = new Map();
    this.shimMap = new Map();
    this.deps = new Map();
    this._initialized = false; // we lazily initialize the maps
  }

  /**
   * @internal Finish initializing the instance by loading the contract and
   * shim maps.
   */
  private lazyInitialize() {
    if (this._initialized) {
      return;
    }
    // initialize the maps
    const build_dir = this.config.build_dir();
    for (const target of this.config.targets()) {
      this.targetMap.set(target, new TargetProject(target, this.config));

      // Read all pre-compile manifest files for the target chain
      const manifest_file =
        path.join(build_dir, target, 'contracts', 'cubist-manifest.json');
      const manifest: PreCompileManifest =
        PreCompileManifest.from_file(manifest_file);
      manifest.files.forEach((file) => {
        if (file.is_shim) {
          // This is a generated file
          for (const contractName of Object.keys(file.contract_dependencies)) {
            if (this.shimMap.has(contractName)) {
              this.shimMap.get(contractName).add(target);
            } else {
              this.shimMap.set(contractName, new Set([target]));
            }
          }
        } else {
          // This is a file with native contracts
          //   -> add each contract to the contractMap
          //   -> save its dependencies
          for (const contractName of Object.keys(file.contract_dependencies)) {
            const maybeTarget = this.contractMap.get(contractName);
            if (maybeTarget && maybeTarget != target) {
              throw new Error(`Unsupported: Contract ${contractName} defined across multiple targets.`);
            }
            this.contractMap.set(contractName, target);
            this.deps.set(contractName, new Set(file.contract_dependencies[contractName]));
          }
        }
      });
    }
    // done initializing!
    this._initialized = true;
  }

  /** Get contract factory given the contract name.
  * @param {ContractName} name - The contract name.
  * @return {ContractFactory} The contract factory.
  * */
  getContractFactory<T extends internal.Contract>(name: ContractName): ContractFactory<T> {
    this.lazyInitialize();
    // Get the native contract factory
    const contractTarget = this.contractMap.get(name);
    if (!contractTarget) {
      throw new Error(`Contract factory ${name} not found`);
    }
    const contractProject: TargetProject = this.targetMap.get(contractTarget);
    const contractFactory = contractProject.getContractFactory(name);

    // Get shim contract factory (might be on zero or many chains)
    const shimFactoryMap = new Map<Target, internal.ContractFactory>();
    for (const [shimTarget, shimName] of this.getShims(name, contractTarget)) {
      const shimProject: TargetProject = this.targetMap.get(shimTarget);
      const shimFactory = shimProject.getContractFactory(shimName);
      shimFactoryMap.set(shimTarget, shimFactory);
    }
    const shimDeps = this.deps.get(name);
    return new ContractFactory<T>(name, this, contractProject, contractFactory, shimFactoryMap,
      shimDeps);
  }

  /** Get an existing deployed contract. This method looks up the contract's
   * deploy receipts in the `deploy` directory unless you explicitly tell it to
   * `ignoreReceipt`s (e.g., because you're trying to get a contract deployed
   * with another tool).
   *
   * :::note
   * For now we only support deploying a contract once so calling
   * `getContract` with the same name but different addresses is not yet
   * supported.
   * :::
   *
   * @param {ContractName} name - The contract name.
   * @param {ContractAddress?} addr - Optional contract address (if more than
   * one contract with same name).
   * @param {boolean} ignoreReceipt - Ignore receipt (e.g., if contract deployed
   * with another tool).
   * @return {Contract<T>} The contract.
   * @throws {Error} If the contract could not be found, if there are multiple
   * contracts and the address argument is omitted, or if the receipt is missing
   * (unless ignoreReceipt is set).
   * */
  getContract<T extends internal.Contract>(name: ContractName,
    addr?: ContractAddress, ignoreReceipt = false): Contract<T> {
    this.lazyInitialize();
    // Get the native contract
    const contractTarget = this.contractMap.get(name);
    if (!contractTarget) {
      throw new Error(`Could not find contract factory for ${name}`);
    }
    const contractProject: TargetProject = this.targetMap.get(contractTarget);
    const contract: NamedContract = contractProject.getNamedContract(name, addr, ignoreReceipt);

    // Get shim contract (might be on zero or many chains)
    const shimMap = new Map<Target, internal.Contract>();
    for (const [shimTarget, shimName] of this.getShims(name, contractTarget)) {
      const shimProject: TargetProject = this.targetMap.get(shimTarget);
      // TODO(Issue #580): once we have proper support for multiple instances
      // of the same contract we need to get the address of the shim
      // corresponding to `contract`.
      const fqnShim = shimProject.getNamedContract(shimName, undefined, ignoreReceipt);
      shimMap.set(shimTarget, fqnShim.inner);
    }
    return new Contract(this, contractProject,
      contract.fqn, contract.inner, shimMap) as Contract<T>;
  }

  /**
   * Return all shim contracts of a given native contract.
   * @param {ContractName} name - The name of the native contract.
   * @param {Target} target - The target of the native contract.
   * @return {[ContractName, Target][]} Shim contracts.
   */
  getShims(name: ContractName, target: Target): Map<Target, ContractName> {
    const shims = new Map();
    const shimTargets: Set<Target> = this.shimMap.get(name);
    if (!shimTargets) {
      return shims;
    }
    for (const t of shimTargets) {
      shims.set(t, name);
    }
    switch (this.config.bridge_provider) {
    case BridgeProvider.Cubist: {
      return shims;
    }
    case BridgeProvider.Axelar: {
      shims.set(target, `${name}Interface`);
      return shims;
    }
    }
  }

  /**
   * Returns a promise that completes once bridges have been established for
   * all contracts in this projects.
   *
   * @param {number} retries - how many times to check
   * @param {number} delayMs - delay in milliseconds between checks
   * @return {boolean} - true if all bridges have been established
   * @throws {Error} if any contract in this project has not been deployed
   */
  async whenBridged(retries = 100, delayMs = 100): Promise<boolean> {
    this.lazyInitialize();
    for (const contractName of this.contractMap.keys()) {
      const contract = this.getContract(contractName);
      const ok = await contract.whenBridged(retries, delayMs);
      if (!ok) {
        return false;
      }
    }
    return true;
  }

  /** Retrieve all managed accounts used on a target chain.
   * @param {Target} target - The target chain.
   * @return {Promise<AccountAddress>} Default signer address.
   **/
  accountsOn(target: Target): Promise<AccountAddress[]> {
    const project = this.targetMap.get(target);
    if (!project) {
      throw new Error(`Invalid target '${target}'`);
    }
    return project.accounts();
  }

  /** Return default signer address on the target chain.
   * @param {Target} target - The target chain.
   * @return {Promise<AccountAddress>} Default signer address. */
  getDefaultSignerAccountOn(target: Target): Promise<AccountAddress> {
    const project = this.targetMap.get(target);
    if (!project) {
      throw new Error(`Invalid target '${target}'`);
    }
    return project.getDefaultSignerAccount();
  }

  /** Return default signer address on the target chain.
   * @param {Target} target - The target chain.
   * @param {AccountAddress | number} addrOrIndex - Account address or index.
   **/
  async setDefaultSignerAccountOn(target: Target, addrOrIndex: AccountAddress | number) {
    const project = this.targetMap.get(target);
    if (!project) {
      throw new Error(`Invalid target '${target}'`);
    }
    return project.setDefaultSignerAccount(addrOrIndex);
  }

  /** @internal Return default signer address on the target chain.
   * @param {Target} target - The target chain.
   * @param {AccountAddressOrIndex} addrOrIndex - Account address or index.
   * @return {Promise<Signer>} The signer. */
  async getSignerOn(target: Target, addrOrIndex: AccountAddressOrIndex): Promise<Signer> {
    const project = this.targetMap.get(target);
    if (!project) {
      throw new Error(`Invalid target '${target}'`);
    }
    return project.getSigner(addrOrIndex);
  }

  /** Get the balance of the given address on the target chain.
   * @param {Target} target - The target chain.
   * @param {Address} addr - The address.
   * @return {Promise<BigNumber>} The balance.
   **/
  getBalanceOn(target: Target, addr: Address): Promise<BigNumber> {
    const project = this.targetMap.get(target);
    if (!project) {
      throw new Error(`Invalid target '${target}'`);
    }
    return project.getBalance(addr);
  }
}

/**
 * Contract factories are used to create {@link Contract}s that span multiple
 * chains. Specifically, with a factory you can use:
 *
 * - {@link deploy} to deploy a {@link Contract} to its native target chain _and_
 *   automatically deploy its shims to the chains where this contract gets
 *   called.
 * - {@link deployShims} to deploy only the shims of the contract on all the
 *   chains the contract is called.
 * - {@link deployWithShims} to deploy the contract to its native target chain
 *   (given its already deployed shims). Together, {@link deployShims} and
 *   {@link deployWithShims}, make it possible to deploy shims before the
 *   native contract.
 * - {@link attach} to attach to an already deployed contract. This is the same
 *   as {@link Cubist.getContract}. We expose {@link attach} because the
 *   well-typed {@link Cubist} interface we generate at build time (with
 *   `cubist build`)---[CubistORM]---exports the project factories as
 *   properties on the object, eliding the need to use `getContractFactory` and
 *   `getContract`.
 *
 * @example
 * Get factory and deploy contract and its shims with {@link Cubist}.
 * ```typescript
 * const StorageReceiver = cubist.getContractFactory('StorageReceiver');
 * const receiver = await StorageReceiver.deploy(33);
 * ```

 * @example
 * Get factory and attach to existing deployed contract.
 * ```typescript
 * import { CubistORM, } from '../build/orm/index.js';
 * // ...
 * const StorageReceiver = cubist.StorageReceiver;
 * const receiver = StorageReceiver.attach();
 * ```
 *
 * [CubistORM]: /jsdoc-md/cubist.CubistORM
 *
 * @group Core
 * */
export class ContractFactory<T extends internal.Contract> {
  private readonly name: ContractName;
  private readonly cubist: Cubist;
  private readonly internalFactory: internal.ContractFactory;
  private readonly shimFactoryMap: Map<Target, internal.ContractFactory>;
  private readonly shimDeps: Set<ContractName>;

  /** Underlying target project. */
  public readonly project: TargetProject;

  /** @internal Create new contract factory. The constructor is not intended to be called
   * directly. Use `getContractFactory` from the `Cubist` class instead.
   * @param {ContractName} name - The contract name.
   * @param {Cubist} cubist - The parent cubist project.
   * @param {TargetProject} project - The target chain project.
   * @param {internal.ContractFactory} internalFactory - The underlying contract factory.
   * @param {Map<Target, internal.ContractFactory>} shimFactoryMap - Map of shim contract factories.
   * @param {Set<ContractName>} shimDeps - Shims on this chain that this contract may call.
    */
  constructor(name: ContractName, cubist: Cubist,
    project: TargetProject,
    internalFactory: internal.ContractFactory,
    shimFactoryMap: Map<Target, internal.ContractFactory>,
    shimDeps: Set<ContractName>) {
    this.name = name;
    this.cubist = cubist;
    this.project = project;
    this.internalFactory = internalFactory;
    this.shimFactoryMap = shimFactoryMap;
    this.shimDeps = shimDeps;
  }

  /** Deploy contract and its shims.
   * This function deploys the contract to its target chain, and the shims to
   * their corresponding chains. We return a contract that encapsulates an
   * inner [ethers.js
   * Contract](https://docs.ethers.org/v5/api/contract/contract/) and exposes
   * some additional methods for interacting with the shims.
   *
   * :::note
   * For now, you can only deploy a single instance of a contract. The next
   * release of cubist will have support for multiple instances (Issue #580).
   * :::
   *
   * @param {any[]} args - Arguments to call contract constructor with.
   * @return {Promise<Contract>} The deployed contract.
   * */
  async deploy(...args: any[]): // eslint-disable-line @typescript-eslint/no-explicit-any
    Promise<Contract<T>> {
    if (this.project.isDeployed(this.name)) {
      throw new Error(`${this.name} was already deployed. Multiple deployments coming soon.`);
    }
    // deploy shims
    const shims = await this.deployShims();
    // deploy native contract
    return this.deployWithShims(shims, ...args);
  }

  /** Deploy contract given the already-deployed shims.
   * This function deploys the {@link Contract} to its native target chain.
   * The first argument is the return value from the {@link deployShims} function.
   * The rest of the arguments are the constructor arguments.
   *
   * This function is useful for deploying cross-chain contracts that mutually
   * depend on each other.
   *
   * @param {Map<Target, T>} shims - the previously deployed shims.
   * @param {any[]} args - Arguments to pass to call contract constructor with.
   * @return {Promise<Contract>} The deployed contract.
   * */
  async deployWithShims(shims: Map<Target, T>,
    ...args: any[]): // eslint-disable-line @typescript-eslint/no-explicit-any
    Promise<Contract<T>> {
    if (this.project.isDeployed(this.name)) {
      throw new Error(`${this.name} was already deployed. Multiple deployments coming soon.`);
    }
    // deploy native contract
    const nativeContract = await this.internalFactory.deploy(...args);
    await this.updateShims(nativeContract.address, shims);

    // for each dependency: make sure it's deployed (`getContract` throws
    // otherwise), and then call `approveCaller`
    for (const depName of this.shimDeps) {
      const depShim: internal.Contract = this.project.getContract(depName);
      // TODO (Issue #513): Consider passing number of confirmations to `wait`
      // according to the target chain properties.
      await (await depShim.approveCaller(nativeContract.address)).wait();
    }

    const c = new Contract(this.cubist, this.project,
      this.internalFactory.fqn(), nativeContract, shims);
    await c.saveDeploymentManifest();
    return c as Contract<T>;
  }

  /**
   * Perform any shim updates after this (native) contract has been deployed.
   * @param {Address} addressOnNativeTarget - The address of the native contract.
   * @param {Map<Target, T>} shims - Deployed shims of this contract.
   */
  async updateShims(addressOnNativeTarget: Address, shims: Map<Target, T>) {
    switch (this.cubist.config.bridge_provider) {
    case BridgeProvider.Cubist: {
      // nothing to do for Cubist relayer
      break;
    }
    case BridgeProvider.Axelar: {
      // only the "axelar_receiver" shim needs to be updated with the address of this contract
      const receiverShim = shims.get(this.target());
      if (receiverShim) {
        const confirmations = 1; /* TODO: specify confirmations in config. */
        await (await receiverShim.setTargetAddress(addressOnNativeTarget)).wait(confirmations);
      }
      break;
    }
    }
  }

  /** Deploy shims for this contract. In some cases you need to deploy the
   * contract shims before the contract itself (see our [TokenBridge] for an
   * example). This method is used to do deploy the shims, which you can then
   * use when deploying the contract itself with {@link deployWithShims}.
   *
   * A contract may have up to one shim per target chain, including
   * its own native chain (e.g., when using Axelar for bridging a "receiver"
   * shim is generated for the contract's native chain).
   *
   * @example In our [TokenBridge] template (`cubist new --template
   * TokenBridge`) we set up a two way bridge across two chains and need to
   * deploy shims on one end to handle the circular dependency---the two
   * contracts mutually depend on each other.
   *
   * ```typescript
   * // deploy ERC20Bridged shims
   * const erc20bShims = await ERC20Bridged.deployShims();
   * // get the shim contract on the token sender chain
   * const erc20BridgedShim = erc20bShims.get(TokenSender.target());
   * // deploy the token sender contract and its shim
   * const tokenSender = await TokenSender.deploy(erc20BridgedShim.address);
   * // Deploy ERC20Bridged with the TokenSender address.
   * const erc20Bridged = await ERC20Bridged.deployWithShims(erc20bShims,
   * ```
   * @return {Promise<Map<Target, T>>} The deployed shims.
   *
   * [TokenBridge]: /guide/advanced-examples/Cross-chain-token-bridge
   */
  async deployShims(): Promise<Map<Target, T>> {
    const shims = new Map();

    // nothing to deploy if no shims
    if (this.shimFactoryMap.size === 0) {
      return shims;
    }

    switch (this.cubist.config.bridge_provider) {
    // all shims have no-arg constructors
    case BridgeProvider.Cubist: {
      for (const target of this.shimFactoryMap.keys()) {
        const shimContract = await this.deployShim(target);
        shims.set(target, shimContract);
      }
      break;
    }
    case BridgeProvider.Axelar: {
      const m = this.project.getAxelarManifest();
      // "axelar_receiver" shim (which is on the same chain) takes only gateway address
      const receiverShim = await this.deployShim(this.target(), m.gateway);
      shims.set(this.target(), receiverShim);
      const receiverShimAddr = receiverShim.address;
      // "axelar_sender" shims (which are on different chains) take
      // (gateway, gasReceiver, receiverShimAddr)
      for (const t of this.shimFactoryMap.keys()) {
        if (t !== this.target()) {
          const senderShim = await this.deployShim(t, m.gateway, m.gasReceiver, receiverShimAddr);
          shims.set(t, senderShim);
        }
      }
      break;
    }
    }
    return shims;
  }

  /** Get the already-deployed contract.
   * @return {Promise<Contract>} The deployed contract.
   */
  async deployed(): Promise<Contract<T>> {
    return this.cubist.getContract(this.name);
  }

  /** Get the already-deployed contract at particular address.
   * @param {ContractAddress} addr - Contract address.
   * @return {Promise<Contract>} The deployed contract.
   */
  async attach(addr: ContractAddress): Promise<Contract<T>> {
    return this.cubist.getContract(this.name, addr);
  }

  /** Deploy shim contract.
   * @param {Target} target - The target chain to deploy shim to.
   * @return {Promise<internal.Contract>} The deployed contract.
   * */
  private async deployShim(
    target: Target,
    ...args: any[] // eslint-disable-line @typescript-eslint/no-explicit-any
  ): Promise<internal.Contract> {
    const shimFactory = this.shimFactoryMap.get(target);
    if (!shimFactory) {
      throw new Error(`Contract '${this.name}'@${this.target()} does not have a shim for target ${target}`);
    }
    const contract = await shimFactory.deploy(...args);
    return contract;
  }

  /** Get (native) target chain.
   * @return {Target} The target chain.
   * */
  target(): Target {
    return this.project.target();
  }
}

/**
 * Multi-chain contract abstraction. Each Cubist contract encapsulates (for
 * now) an [ethers.js
 * Contract](https://docs.ethers.org/v5/api/contract/contract/)) that runs on a
 * _native target chain_ and zero or more _shim contracts_ running on other
 * chains.
 *
 * A contract deployed with {@link ContractFactory} is deployed to the chain
 * specified in the `cubist-config.json` configuration file; this is the native
 * target chain. If this contract is called on another chain, we also deploy
 * a _shim_ for this contract on that chain (either automatically when you use
 * {@link ContractFactory.deploy} or manually when you use
 * {@link ContractFactory.deployShims}).
 *
 * This class exposes the contract on the native target chains (via {@link
 * inner}), and several methods for getting the contract {@link target} chain,
 * its {@link address} on the native target chain, and its shims' {@link
 * addressOn | addresses on} other chains.
 *
 * @example ERC20 bridged from Avalanche to Polygon and Ethereum has a native
 * contract on Avalanche and corresponding shims on the other two chains.
 *
 * ```typescript
 * // ...
 * const cubist = new Cubist();
 * // get contract
 * const e20Bridged = cubist.getContract('ERC20Bridged');
 * // print its address on native chain
 * console.log(`address on ${e20Bridged.target()}: ${e20Bridged.address()}`);
 * // print its shims' addresses
 * console.log(`address on Polygon: ${e20Bridged.addressOn(Target.Polygon)}`);
 * console.log(`address on Ethereum: ${e20Bridged.addressOn(Target.Ethereum)}`);
 * ```
 *
 * @group Core
 * */
export class Contract<T extends internal.Contract> {
  private readonly cubist: Cubist;
  /** The single-chain target project corresponding to the target chain this
   * contract was deployed to. In general you don't need to access the project
  * itself. */
  public readonly project: TargetProject;

  /** Fully qualified contract name. */
  public readonly fqn: ContractFQN;

  /**
   * The underlying (for now
   * [ethers.js](https://docs.ethers.org/v5/api/contract/contract/)) native
   * contract. This is ultimately the contract you will invoke methods on,
   * listen for events on, etc.
   * */
  public get inner(): T {
    return this._inner;
  }
  private _inner: T;

  /** Any shims that may be defined for other chains. */
  private readonly shims: Map<Target, internal.Contract>;

  /** @return {Target} - The target chain the contract was deployed to. */
  public target(): Target {
    return this.project.target();
  }

  /** @internal Create new contract. The constructor is not intended to be called
   * directly. Use {@link Cubist.getContract} instead (or get a
   * contract by {@link deploy}ing it via a factory).
   * @param {Cubist} cubist - The cubist project this contract is part of.
   * @param {TargetProject} target - The target chain project.
   * @param {ContractFQN} fqn - The contract fully qualified name.
   * @param {T} inner - The underlying contract.
   * @param {Map<Target, internal.Contract>} shims - Map of shim contracts.
   */
  constructor(cubist: Cubist, target: TargetProject, fqn: ContractFQN, inner: T,
    shims: Map<Target, internal.Contract>) {
    this.cubist = cubist;
    this.project = target;
    this.fqn = fqn;
    this._inner = inner;
    this.shims = shims;
  }

  /** Get contract address of this contract on a particular target chain.
   * @param {Target} target - The target chain.
   * @return {ContractAddress} The contract address.
   */
  public addressOn(target: Target): ContractAddress {
    if (target == this.project.target()) {
      return this.inner.address;
    } else {
      const maybeShim = this.shims.get(target);
      if (maybeShim) {
        return maybeShim.address;
      }
      throw new Error(`Contract not deployed on ${target}`);
    }
  }

  /** Get contract address on the native target chain.
   * @return {ContractAddress} The contract address.
   */
  public address(): ContractAddress {
    return this.addressOn(this.project.target());
  }

  /**
   * Returns a promise that completes once the bridge between this contract and
   * its shims has been established. In general, you don't need to call this
   * yourself; the top-level {@link Cubist.whenBridged} does this for all contracts.
   *
   * @param {number} retries - how many times to check if the bridge has been established.
   * @param {number} delayMs - delay in milliseconds between retries.
   * @return {boolean} - whether a bridge has been established within the given time parameters.
   */
  public async whenBridged(retries = 100, delayMs = 100): Promise<boolean> {
    // contracts without shims need no bridging
    if (this.shims.size == 0) {
      return true;
    }

    // Axelar relayer does not dynamically monitor for individual contract deployments
    if (this.project.config.bridge_provider === BridgeProvider.Axelar) {
      return true;
    }

    const tryIsFile = (p: PathBuf) => {
      try {
        return statSync(p).isFile();
      } catch {
        return false;
      }
    };

    const bridgedPath = this.deploymentManifestBridgedPath();
    for (let i = 0; i < retries; i++) {
      if (tryIsFile(bridgedPath)) {
        return true;
      }
      await new Promise((r) => setTimeout(r, delayMs));
    }
    return false;
  }

  /** Set the signer on the native target chain.
   * This replaces the {@link inner} contract with a new contract that uses a
   * different signer address.
   *
   * In general, you don't want to keep a local reference to {@link inner}
   * unless you want to have multiple copies of the contract with different
   * signers.
   *
   * In future versions we might make the effect of setting the signer a more
   * "global" effect (e.g., by making {@link inner} a proxy object).
   * @param {AccountAddressOrIndex} addrOrIndex - Account address or index.
   */
  async setSigner(addrOrIndex: AccountAddressOrIndex) {
    const signer = this.project.getSigner(addrOrIndex);
    this._inner = this._inner.connect(signer) as T;
  }

  /** Set the signer on a target (shim) chain (like {@link setSigner} does for
   * the native target).
    * @param {Target} target - Target chain.
    * @param {AccountAddressOrIndex} addrOrIndex - Account address or index.
    */
  async setSignerOn(target: Target, addrOrIndex: AccountAddressOrIndex) {
    const shim0 = this.shims.get(target);
    if (!shim0) {
      throw new Error(`No shim contract on ${target} chain`);
    }
    const signer = await this.cubist.getSignerOn(target, addrOrIndex);
    const shim1 = shim0.connect(signer);
    this.shims.set(target, shim1);
  }

  /**
   * @internal
   * Creates a manifest for this contract and saves it to disk (in the {@link
   * Config.deploy_dir} directory).
   */
  async saveDeploymentManifest() {
    const dm = <DeploymentManifest> {
      contract: this.fqn,
      target: this.project.target(),
      address: this.inner.address,
      shims: [...this.shims].map((x) => <DeploymentInfo>{
        target: x[0],
        address: x[1].address,
      }),
    };

    // Manifest path: deploy/cubist-deploy/{contract_name}-{address}.json
    const manifestPath = this.deploymentManifestPath();
    await writeAtomic(dm, manifestPath);
  }

  /** @internal
   * @return {PathBuf} - Directory where deployment manifest files are to be written.
   * */
  deploymentManifestDir(): PathBuf {
    return path.join(this.project.config.deploy_dir(), 'cubist-deploy');
  }

  /** @internal
   * @return {PathBuf} - File stem of the deployment manifest file
   * */
  deploymentManifestStem(): string {
    return `${this.fqn.name}-${this.inner.address}`;
  }

  /** @internal
   * @return {PathBuf} - Full path to the deployment manifest file
   * */
  deploymentManifestPath(): PathBuf {
    return path.join(this.deploymentManifestDir(), `${this.deploymentManifestStem()}.json`);
  }

  /** @internal
   * @return {PathBuf} - Full path to the file indicating that the deployment
   * has been bridged
   * */
  deploymentManifestBridgedPath(): PathBuf {
    return path.join(this.deploymentManifestDir(), `${this.deploymentManifestStem()}.bridged`);
  }
}
